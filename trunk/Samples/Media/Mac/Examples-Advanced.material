// -------------------------------
// Cel Shading Section
// -------------------------------
vertex_program Ogre/CelShadingVP asm
{
	source CelShadingVP.asm
	syntax arbvp1
}

fragment_program Ogre/CelShadingFP asm
{
	source CelShadingFP.asm
	syntax arbfp1
}


material Examples/OgreCelShading/Eyes
{
	technique
	{
		pass
		{
			vertex_program_ref Ogre/CelShadingVP
			{
				param_indexed_auto 0 light_position_object_space 0
				param_indexed_auto 1 camera_position_object_space
				param_indexed 2 float4 35 0 0 0
				param_indexed_auto 3 worldviewproj_matrix
			}
			fragment_program_ref Ogre/CelShadingFP
			{
				param_indexed 0 float4 1 0.3 0.3 1
				param_indexed 1 float4 1 0.6 0.6 1
			}
			texture_unit
			{
				texture cel_shading_diffuse.png 1d
				tex_address_mode clamp
				filtering none
			}
			texture_unit
			{
				texture cel_shading_specular.png 1d
				tex_address_mode clamp
				filtering none
			}
			texture_unit
			{
				texture cel_shading_edge.png 1d
				tex_address_mode clamp
				filtering none
			}
		}
	}
	
}

material Examples/OgreCelShading/Skin
{
	technique
	{
		pass
		{
			vertex_program_ref Ogre/CelShadingVP
			{
				param_indexed_auto 0 light_position_object_space 0
				param_indexed_auto 1 camera_position_object_space
				param_indexed 2 float4 10 0 0 0
				param_indexed_auto 3 worldviewproj_matrix
			}
			fragment_program_ref Ogre/CelShadingFP
			{
				param_indexed 0 float4 0 0.5 0 1
				param_indexed 1 float4 0.3 0.5 0.3 1
			}
			texture_unit
			{
				texture cel_shading_diffuse.png 1d
				tex_address_mode clamp
				filtering none
			}
			texture_unit
			{
				texture cel_shading_specular.png 1d
				tex_address_mode clamp
				filtering none
			}
			texture_unit
			{
				texture cel_shading_edge.png 1d
				tex_address_mode clamp
				filtering none
			}
			
		}
	}
}

material Examples/OgreCelShading/Teeth
{
	technique
	{
		pass
		{
			vertex_program_ref Ogre/CelShadingVP
			{
				param_indexed_auto 0 light_position_object_space 0
				param_indexed_auto 1 camera_position_object_space
				param_indexed 2 float4 20 0 0 0
				param_indexed_auto 3 worldviewproj_matrix
			}
			fragment_program_ref Ogre/CelShadingFP
			{
				param_indexed 0 float4 1 1 0.7 1
				param_indexed 1 float4 1 1 1 1
			}
			texture_unit
			{
				texture cel_shading_diffuse.png 1d
				tex_address_mode clamp
				filtering none
			}
			texture_unit
			{
				texture cel_shading_specular.png 1d
				tex_address_mode clamp
				filtering none
			}
			texture_unit
			{
				texture cel_shading_edge.png 1d
				tex_address_mode clamp
				filtering none
			}
			
		}
	}
}

material Examples/OgreCelShading/Earring
{
	technique
	{
		pass
		{
			vertex_program_ref Ogre/CelShadingVP
			{
				param_indexed_auto 0 light_position_object_space 0
				param_indexed_auto 1 camera_position_object_space
				param_indexed 2 float4 25 0 0 0
				param_indexed_auto 3 worldviewproj_matrix
			}
			fragment_program_ref Ogre/CelShadingFP
			{
				param_indexed 0 float4 1 1 0 1
				param_indexed 1 float4 1 1 0.7 1
			}

			texture_unit
			{
				texture cel_shading_diffuse.png 1d
				tex_address_mode clamp
				filtering none
			}
			texture_unit
			{
				texture cel_shading_specular.png 1d
				tex_address_mode clamp
				filtering none
			}
			texture_unit
			{
				texture cel_shading_edge.png 1d
				tex_address_mode clamp
				filtering none
			}
		}
	}
}

//------------------------
// Bump mapping section
//------------------------

// Bump map vertex program, support for this is required
vertex_program Examples/BumpMapVP asm
{
	source BumpMapVP.asm
	syntax arbvp1
}

// Bump map fragment program, support for this is optional
fragment_program Examples/BumpMapFP asm
{
	source BumpMapFP.asm
	syntax arbfp1
}

// Bump map with specular vertex program, support for this is required
vertex_program Examples/BumpMapVPSpecular asm
{
	source BumpMapVPSpecular.asm
	syntax arbvp1
}

// Bump map fragment program, support for this is optional
fragment_program Examples/BumpMapFPSpecular asm
{
	source BumpMapFPSpecular.asm
	syntax arbfp1
}

// Single light material, less passes (one pass on a 4-unit card)
material Examples/BumpMapping/SingleLight
{
	// Preferred technique, uses vertex and fragment programs
	// to support a single coloured light
	technique
	{
		pass
		{
			// Vertex program reference
			vertex_program_ref Examples/BumpMapVP
			{
				param_indexed_auto 0 light_position_object_space 0
				param_indexed_auto 1 camera_position_object_space
				param_indexed_auto 2 worldviewproj_matrix
			}

			// Fragment program
			fragment_program_ref Examples/BumpMapFP
			{
				param_indexed_auto 0 light_diffuse_colour 0 
			}
			
			// Base bump map
			texture_unit
			{
				texture NMBumpsOut.png
				colour_op replace
			}
			// Normalisation cube map
			texture_unit
			{
				cubic_texture nm.png combinedUVW
				tex_coord_set 1
				tex_address_mode clamp
			}
			// Decal
			texture_unit
			{
				texture RustySteel.jpg
			}
		}
	}
	// Fallback technique, uses vertex program but only fixed-function
	// fragment shading, which does not support coloured light
	technique
	{
		pass
		{
			// Vertex program reference
			vertex_program_ref Examples/BumpMapVP
			{
				param_indexed_auto 0 light_position_object_space 0
				param_indexed_auto 1 camera_position_object_space
				param_indexed_auto 2 worldviewproj_matrix
			}

			// Base bump map
			texture_unit
			{
				texture NMBumpsOut.png
				colour_op replace
			}
			// Normalisation cube map
			texture_unit
			{
				cubic_texture nm.png combinedUVW
				tex_coord_set 1
				tex_address_mode clamp
				colour_op_ex dotproduct src_texture src_current
				colour_op_multipass_fallback dest_colour zero
			}
			// Decal
			texture_unit
			{
				texture RustySteel.jpg
			}
		}
	}
}

// Any number of lights, diffuse
material Examples/BumpMapping/MultiLight
{

	// This is the preferred technique which uses both vertex and
	// fragment programs, supports coloured lights
	technique
	{
		// Base ambient pass
		pass
		{
			// Really basic vertex program
			// NB we don't use fixed function here because GL does not like
			// mixing fixed function and vertex programs, depth fighting can
			// be an issue
			vertex_program_ref Ogre/BasicVertexPrograms/AmbientOneTexture
			{
				param_indexed_auto 0 worldviewproj_matrix
				param_indexed_auto 4 ambient_light_colour
			}
			
		}
		// Now do the lighting pass
		// NB we don't do decal texture here because this is repeated per light
		pass
		{
			// do this for each light
			iteration once_per_light

		
			scene_blend add

			// Vertex program reference
			vertex_program_ref Examples/BumpMapVP
			{
				param_indexed_auto 0 light_position_object_space 0
				param_indexed_auto 1 camera_position_object_space
				param_indexed_auto 2 worldviewproj_matrix
			}

			// Fragment program
			fragment_program_ref Examples/BumpMapFP
			{
				param_indexed_auto 0 light_diffuse_colour 0 
			}
			
			// Base bump map
			texture_unit
			{
				texture NMBumpsOut.png
				colour_op replace
			}
			// Normalisation cube map
			texture_unit
			{
				cubic_texture nm.png combinedUVW
				tex_coord_set 1
				tex_address_mode clamp
			}
		}
		
		// Decal pass
		pass
		{
			// Really basic vertex program
			// NB we don't use fixed function here because GL does not like
			// mixing fixed function and vertex programs, depth fighting can
			// be an issue
			vertex_program_ref Ogre/BasicVertexPrograms/AmbientOneTexture
			{
				param_indexd_auto 0 worldviewproj_matrix
				param_indexed 4 float4 1 1 1 1
			}
			scene_blend dest_colour zero
			texture_unit
			{
				texture RustedMetal.jpg 
			}
			
		}
	}

	// This is the fallback which cards which don't have fragment program 
	// support will use
	// Note that it still requires vertex program support
	technique
	{
		// Base ambient pass
		pass
		{
			// Really basic vertex program
			// NB we don't use fixed function here because GL does not like
			// mixing fixed function and vertex programs, depth fighting can
			// be an issue
			vertex_program_ref Ogre/BasicVertexPrograms/AmbientOneTexture
			{
				param_indexed_auto 0 worldviewproj_matrix
				param_indexed_auto 4 ambient_light_colour
			}
			
		}
		// Now do the lighting pass
		// NB we don't do decal texture here because this is repeated per light
		pass
		{
			// do this for each light
			iteration once_per_light

		
			scene_blend add

			// Vertex program reference
			vertex_program_ref Examples/BumpMapVP
			{
				param_indexed_auto 0 light_position_object_space 0
				param_indexed_auto 1 camera_position_object_space
				param_indexed_auto 2 worldviewproj_matrix
			}
			
			// Base bump map
			texture_unit
			{
				texture NMBumpsOut.png
				colour_op replace
			}
			// Normalisation cube map, with dot product on bump map
			texture_unit
			{
				cubic_texture nm.png combinedUVW
				tex_coord_set 1
				tex_address_mode clamp
				colour_op_ex dotproduct src_texture src_current
				colour_op_multipass_fallback dest_colour zero
			}
		}
		
		// Decal pass
		pass
		{
			// Really basic vertex program
			// NB we don't use fixed function here because GL does not like
			// mixing fixed function and vertex programs, depth fighting can
			// be an issue
			vertex_program_ref Ogre/BasicVertexPrograms/AmbientOneTexture
			{
				param_indexed_auto 0 worldviewproj_matrix
				param_indexed 4 float4 1 1 1 1
			}
			scene_blend dest_colour zero
			texture_unit
			{
				texture RustedMetal.jpg 
			}
			
		}

	}
}

// Any number of lights, diffuse and specular
material Examples/BumpMapping/MultiLightSpecular
{

	// This is the preferred technique which uses both vertex and
	// fragment programs, supports coloured lights
	technique
	{
		// Base ambient pass
		pass
		{
			// Really basic vertex program
			// NB we don't use fixed function here because GL does not like
			// mixing fixed function and vertex programs, depth fighting can
			// be an issue
			vertex_program_ref Ogre/BasicVertexPrograms/AmbientOneTexture
			{
				param_indexed_auto 0 worldviewproj_matrix
				param_indexed_auto 4 ambient_light_colour
			}
			
		}
		// Now do the lighting pass
		// NB we don't do decal texture here because this is repeated per light
		pass
		{
			// do this for each light
			iteration once_per_light

		
			scene_blend add

			// Vertex program reference
			vertex_program_ref Examples/BumpMapVPSpecular
			{
				param_indexed_auto 0 light_position_object_space 0
				param_indexed_auto 1 camera_position_object_space
				param_indexed_auto 2 worldviewproj_matrix
			}

			// Fragment program
			fragment_program_ref Examples/BumpMapFPSpecular
			{
				param_indexed_auto 0 light_diffuse_colour 0 
				param_indexed_auto 1 light_specular_colour 0
			}
			
			// Base bump map
			texture_unit
			{
				texture NMBumpsOut.png
				colour_op replace
			}
			// Normalisation cube map
			texture_unit
			{
				cubic_texture nm.png combinedUVW
				tex_coord_set 1
				tex_address_mode clamp
			}
			// Normalisation cube map #2
			texture_unit
			{
				cubic_texture nm.png combinedUVW
				tex_coord_set 1
				tex_address_mode clamp
			}
		}
		
		// Decal pass
		pass
		{
			// Really basic vertex program
			// NB we don't use fixed function here because GL does not like
			// mixing fixed function and vertex programs, depth fighting can
			// be an issue
			vertex_program_ref Ogre/BasicVertexPrograms/AmbientOneTexture
			{
				param_indexed_auto 0 worldviewproj_matrix
				param_indexed 4 float4 1 1 1 1
			}
			scene_blend dest_colour zero
			texture_unit
			{
				texture RustedMetal.jpg 
			}
			
		}
	}

	// This is the fallback which cards which don't have fragment program 
	// support will use, NB does not support specular colour
	// Note that it still requires vertex program support
	technique
	{
		// Base ambient pass
		pass
		{
			// Really basic vertex program
			// NB we don't use fixed function here because GL does not like
			// mixing fixed function and vertex programs, depth fighting can
			// be an issue
			vertex_program_ref Ogre/BasicVertexPrograms/AmbientOneTexture
			{
				param_indexed_auto 0 worldviewproj_matrix
				param_indexed_auto 4 ambient_light_colour
			}
			
		}
		// Now do the lighting pass
		// NB we don't do decal texture here because this is repeated per light
		pass
		{
			// do this for each light
			iteration once_per_light

		
			scene_blend add

			// Vertex program reference
			vertex_program_ref Examples/BumpMapVP
			{
				param_indexed_auto 0 light_position_object_space 0
				param_indexed_auto 1 camera_position_object_space
				param_indexed_auto 2 worldviewproj_matrix
			}
			
			// Base bump map
			texture_unit
			{
				texture NMBumpsOut.png
				colour_op replace
			}
			// Normalisation cube map, with dot product on bump map
			texture_unit
			{
				cubic_texture nm.png combinedUVW
				tex_coord_set 1
				tex_address_mode clamp
				colour_op_ex dotproduct src_texture src_current
				colour_op_multipass_fallback dest_colour zero
			}
		}
		
		// Decal pass
		pass
		{
			// Really basic vertex program
			// NB we don't use fixed function here because GL does not like
			// mixing fixed function and vertex programs, depth fighting can
			// be an issue
			vertex_program_ref Ogre/BasicVertexPrograms/AmbientOneTexture
			{
				param_indexed_auto 0 worldviewproj_matrix
				param_indexed 4 float4 1 1 1 1
			}
			scene_blend dest_colour zero
			texture_unit
			{
				texture RustedMetal.jpg 
			}
			
		}

	}
}
