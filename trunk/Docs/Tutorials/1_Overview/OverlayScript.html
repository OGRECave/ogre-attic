<html>
<head>
<title>Tutorial: Overlay Scripts</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><STYLE TYPE="text/css">
<!--
.MainHeader {  font-weight: bold; color: #FFFF33; background-color: #006600; font-size: 10pt}
body {  font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt; color: #CCFFCC; background-color: #003300}
.BorderHeader {  background-color: #999900; font-size: 8pt; font-weight: bold; color: #333300; text-align: center}
.MainContent { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt; color: #CCFFCC }
.BorderContent {  font-size: 8pt; color: #66CC33; border-color: black #666600 #666600; padding-top: 2px; padding-right: 2px; padding-bottom: 10px; padding-left: 2px; margin-bottom: 2px; border-style: solid; border-top-width: 0px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px}
a:link {  color: #FFFF00; text-decoration: underline}
a:hover {  color: #FFFFFF; text-decoration: underline}
a:visited {  color: #FFCC66; text-decoration: underline}
li {  color: #66CC33; list-style-type: circle; position: relative; left: -15px; clip:    rect(   )}
.NewsDate {  color: #CCFFCC; font-weight: bold}
td {  font-size: 10pt}
th {  font-size: 10pt}
.Annotation {  font-size: 10px}

H1 { text-align: center; }
A.qindex {}
A.qindexRef {}
A.el { text-decoration: none; font-weight: bold }
A.elRef { font-weight: bold }
A.code { text-decoration: none; font-weight: normal; color: #4444ee }
A.codeRef { font-weight: normal; color: #4444ee }
DL.el { margin-left: -1cm }
DIV.fragment { width: 100%; border: none; background-color: #003300 }
DIV.ah { background-color: black; margin-bottom: 3; margin-top: 3 }
TD.md { background-color: #006600 }
DIV.groupHeader { margin-left: 16; margin-top: 12; margin-bottom: 6; font-weight: bold }
DIV.groupText { margin-left: 16; font-style: italic; font-size: smaller }
FONT.keyword       { color: #008000 }
FONT.keywordtype   { color: #999920 }
FONT.keywordflow   { color: #e0FF00 }
FONT.comment       { color: #009900 }
FONT.preprocessor  { color: #809020 }
FONT.stringliteral { color: #002080 }
FONT.charliteral   { color: #008080 }

H3 {
    FONT-FAMILY: trebuchet ms,helvetica,arial
}

.ex {
    FONT-SIZE: 8pt; FONT-FAMILY: tahoma
}
CODE.keywordtype {
    COLOR: #00ccff
}
CODE.keyword {
    FONT-WEIGHT: bold; COLOR: #00ccff
}
CODE.fn {
    COLOR: white;
    FONT-WEIGHT: bold;
}
CODE.var {
    COLOR: #dcdcdc;
}
CODE.macro {
    COLOR: #809020;
    FONT-WEIGHT: bold;
}
CODE.comm {
    COLOR: lime
}
CODE.num {
    COLOR: purple
}
CODE.str {
    COLOR: #ffcc33;
    font-style: italic
}
.SectionHeader {  font-size: 14px; color: #FFFFCC; font-weight: bold}
.header {  font-size: 16px; font-weight: bold; color: #FFFFCC}
-->
</STYLE> 
</head>

<body bgcolor="#FFFFFF" text="#000000">
<p align="center" class="header">OGRE (Object-Oriented Graphics Rendering Engine)</p><p align="center" class="header">Material 
Scripts</p><p align="left" class="MainHeader">&nbsp;</p><P ALIGN="LEFT" CLASS="SectionHeader">Overlay 
scripts</P><P ALIGN="LEFT">Overlay scripts offer you the ability to define overlays 
in a script which can be reused easily. Whilst you could set up all overlays for 
a scene in code using the methods of the SceneManager, Overlay and GuiElement 
classes, in practice it's a bit unwieldy. Instead you can store overlay definitions 
in text files which can then be loaded whenever required.</P><P ALIGN="LEFT" CLASS="SectionHeader">Loading 
scripts</P><P ALIGN="LEFT">Overlay scripts are loaded at initialisation time by 
the system: by default it looks in all common resource locations (see Root::addResourceLocation) 
for files with the '.overlay' extension and parses them. If you want to parse 
files with a different extension, use the OverlayManager::getSingleton().parseAllSources 
method with your own extension, or if you want to parse an individual file, use 
OverlayManager::getSingleton().parseScript.</P><P ALIGN="LEFT" CLASS="SectionHeader">Format</P><P ALIGN="LEFT">Several 
overlays may be defined in a single script. The script format is pseudo-C++, with 
sections delimited by curly braces ({}), and comments indicated by starting a 
line with '//' (note, no nested form comments allowed). The general format is 
shown below in a typical example:</P><HR><P>// The name of the overlay comes first<BR>MyOverlays/ANewOverlay<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;zorder 
200<BR><BR> &nbsp;&nbsp;&nbsp;&nbsp;container Panel(MyGuiElements/TestPanel)<BR> 
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
Center it horzontally, put it at the top<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left 
0.25<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width 
0.5<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height 0.1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;material 
MyMaterials/APanelMaterial<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
Another panel nested in this one<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;container 
Panel(MyGuiElements/AnotherPanel)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left 
0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top 
0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width 
0.1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height 
0.1 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;material 
MyMaterials/NestedPanel<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR><BR>} 
</P><HR><P ALIGN="LEFT">The above example defines a single overlay called 'MyOverlays/ANewOverlay', 
with 2 panels in it, one nested under the other.</P><P ALIGN="LEFT">Every overlay 
in the script must be given a name, which is the line before the first opening 
'{'. This name must be globally unique. It can include path characters (as in 
the example) to logically divide up your overlays, and also to avoid duplicate 
names, but the engine does not treat the name a hierarchical, just as a string.</P><P ALIGN="LEFT">Within 
the braces are the properties of the overlay, and any nested elements. The overlay 
itself only has a single property 'zorder' which determines how'high' it is in 
the stack of overlays if more than one is displayed at the same time. Overlays 
with higher zorder values are displayed on top.</P><P ALIGN="LEFT">Within an overlay, 
you can include any number of 2D or 3D elements. You do this by defining a nested 
block headed by:</P><UL><LI>'<A HREF="#element">element</A>' if you want to define 
a 2D element which cannot have children of it's own</LI><LI>'<A HREF="#element">container</A>' 
if you want to define a 2D container object (which may itself have nested containers 
or elements)</LI><LI>'<A HREF="#entity">entity</A>' if you want to include a 3D 
element (can only occur directly under the overlay, not under a 2D element)</LI></UL><P>The 
element and container blocks are pretty identical apart from their ability to 
store nested blocks.</P><P CLASS="SectionHeader"><A NAME="element"></A>'container' 
/ 'element' blocks</P><P>These are delimited by curly braces. The format for the 
header preceding the first brace is:</P><P>[container | element] &lt;type_name&gt; 
( &lt;instance_name&gt;)<BR>{ ...</P><P>type_name: Must resolve to the name of 
a GuiElement type which has been registered with the GuiManager. Plugins register 
with the GuiManager to advertise their ability to create elements, and at this 
time advertise the name of the type. OGRE comes preconfigured with types 'Panel', 
'BorderPanel' and 'TextArea'.</P><P>instance_name: Must be a name unique among 
all other elements / containers by which to identify the element. Note that you 
can obtain a pointer to any named element by calling GuiManager::getSingleton().getGuiElement(name).</P><P>The 
properties which can be included within the braces depend on the custom type. 
However the following are always valid:</P><P ALIGN="LEFT" CLASS="SectionHeader">Common 
element attributes </P><UL><LI><A HREF="OverlayScriptAttributes.html#left">left</A></LI><LI><A HREF="OverlayScriptAttributes.html#top">top</A></LI><LI><A HREF="OverlayScriptAttributes.html#width">width</A></LI><LI><A HREF="OverlayScriptAttributes.html#height">height</A></LI><LI><A HREF="OverlayScriptAttributes.html#material">material</A></LI><LI><A HREF="OverlayScriptAttributes.html#caption">caption</A></LI></UL><P CLASS="SectionHeader"><A></A><A NAME="entity"></A>'entity' 
blocks </P><P>These are delimited by curly braces. The format for the header preceding 
the first brace is:</P><P>entity &lt;mesh_name&gt; ( &lt;entity_name&gt;)<BR>{ 
...</P><P>mesh_name: The name of a .mesh file defining the entity geometry</P><P>entity_name: 
The name to give the entity created, must be unique to this entity.</P><P>You 
can also define the following properties:</P><UL><LI><A HREF="OverlayScriptAttributes.html#position">position</A></LI><LI><A HREF="OverlayScriptAttributes.html#rotation">rotation</A></LI></UL><P>Note 
that material names are loaded from the .mesh, although you can override the material 
definition in a .material script.</P><TABLE WIDTH="100%" BORDER="0" CELLSPACING="2" CELLPADDING="0"><TR><TD WIDTH="14%"><A HREF="index.html">Back 
to Index</A></TD><TD WIDTH="39%">&nbsp;</TD><TD WIDTH="22%"><A HREF="Overlays.html">&lt;&lt; 
Previous section</A></TD><TD WIDTH="25%"><A HREF="OverlayScriptAttributes.html">Next 
section &gt;&gt;</A></TD></TR></TABLE><P>&nbsp;</P><P>&nbsp;</P><P>&nbsp;</P><P CLASS="SectionHeader">&nbsp;</P>
</body>
</html>
