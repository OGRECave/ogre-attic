OGRE Developer Guide
====================
Steve Streeting <sinbad@ogre3d.org>
v1.0, 11 March 2010

This document sets out the principles under which OGRE development will be undertaken, 
and is designed to be used as an introduction for new developers, and a reference for
existing developers. 

Mercurial Configuration
-----------------------
OGRE uses Mercurial for source control, this is a Distributed Version Control System (DVCS), which means that
while there is a central repository which is considered 'authorative', in fact everyone is able to clone their own
copy of the repository and commit to it themselves too, with changes being exchanged by 'pushing' and 'pulling' changesets
(commits) between repository clones. 

For an introduction to Mercurial, please read http://mercurial.selenic.com/wiki/Tutorial[the official Mercurial tutorials] or
http://hginit.com[Joel Spolsky's tutorials]. However, please note particularly in the case of the latter that the OGRE team's
recommeded approach to using Mercurial differs slightly, with respect to the following cases:
* How to resolve the case where another user pushed their changes to the master before you
* How stable version branches are handled

So please keep that in mind. This document will not teach you the basics of using Mercurial since other documents do that already, 
but we will cover recommended configurations for OGRE and accepted approaches to common issues.

There are some common settings that you should have set in your Mercurial configuration, which can be made globally
in ~/.hgrc on Linux and Mac OS X, or C:\Documents and Settings\'User'\mercurial.ini on Windows. 

UI Section
~~~~~~~~~~

User name
^^^^^^^^^

At the very minimum, you need to define your user name and email address, which identifies you:
------------------------------------------------------------
[ui]
username = Joe Bloggs <joe@bloggs.com>
------------------------------------------------------------

Ignore List
^^^^^^^^^^^

Also in this section, you're likely to want to define a global ignore list, so that you don't have to 
configure ignored files per repository. For example:
------------------------------------------------------------
[ui]
username = Joe Bloggs <joe@bloggs.com>
ignore=c:\hgignore_global.txt
------------------------------------------------------------

So here (on Windows) I'm referencing an ignore list file I've created at c:\hgignore_global.txt. 
A pretty good start for a global ignore list might look like this:

------------------------------------------------------------
syntax: glob 

*~
*.orig
*.rej
*.swp 
.#* 
*.obj 
*.o
*.a
*.ncb 
*.ilk 
*.exe 
*.dll 
*.lib 
*.manifest 
*.pdb 
*.idb 
*.rsp 
*.pch 
*.dep
*.so
*.dylib
*.framework
------------------------------------------------------------
You can obviously add more elements to that if you wish. 

Extensions
~~~~~~~~~~

We recommend enabling a few Mercurial extensions for OGRE development; this is done quite simply in the configuration file. 

Common Extensions
^^^^^^^^^^^^^^^^^
Your configuration file should include at least the following:

------------------------------------------------------------
[extensions]
progress=
rebase=
transplant=
------------------------------------------------------------
The Progress extension just gives you more feedback on the progress of operations. 

The Rebase extension allows you re-apply your commits on top of changes in the master repository, when someone else
has pushed their changes to the master before you have. This avoids having to explicitly merge your changes with theirs, keeping a 
messy history; it effectively looks as if you had applied your changes on top of their in the first place.

The Transplant extension allows you to pull individual commits from one branch to another, should you need to.
Typically changes are merged between branches but occasionally there are cases where you need to transplant individual ones.

Windows Text Handling
^^^^^^^^^^^^^^^^^^^^^
Because Windows handles line endings differently to Linux and OS X, you will need some extra entries in your configuration:

------------------------------------------------------------
# inside [extensions]
hgext.win32text=

[encode]
** = cleverencode:
[decode]
** = cleverdecode:
[hooks]
# Reject commits which would introduce windows-style text" files
pretxncommit.crlf = python:hgext.win32text.forbidcrlf
------------------------------------------------------------

This is 'very important' - by default Mercurial performs no line-ending conversion. By enabling the win32text 
extension, you cause all text files to be converted to Unix line endings before commit, and converted to Windows
line endings when your working copy is updated. This keeps everything consistent. 

The cleverencode and cleverdecode entries determine whether a file is text by looking to see if
there are any NUL characters in the file; if there are none, it is assumed to be text, if there are one or
more NULs then it's considered to be binary.

The hook defined at the bottom is included to prevent accidental committing of files with remaining Windows line feeds. 

Using Mercurial
---------------

Hopefully you're familiar with the basic principles of using Mercurial already; if not, please revisit the 
http://mercurial.selenic.com/wiki/Tutorial[the official Mercurial tutorials]. However, Mercurial is very flexible 
so some ground rules need to be established in order for the team to stay organised.

General Points
~~~~~~~~~~~~~~

Master Repository
^^^^^^^^^^^^^^^^^
The ''master'' repository is located on BitBucket here: http://bitbucket.org/sinbad/ogre/ . I recommend that developers
use the SSH link (with SSH keys if you like) rather than https, because it's more reliable when doing large transactions
because the timeout is far larger.

Official Branches
^^^^^^^^^^^^^^^^^
The master repository will use branches 'only' for official development streams, which in practice means one branch per major stable version, 
plus the default branch (which is considered "unstable"). For example, this might be the list of branches in the master repository:

-----------------------------------------
default
v1-7
v1-6
-----------------------------------------

When we were using Subversion, we used branches for other purposes too such as experimental work by a core team member which was uncertain 
for official inclusion, or a student project on Google Summer of Code - we will no longer use branches for these things. 
Instead all other divergences in the code will be handled by making clones of the repository and not by 
branches. If these clones need to be public, then a fork should be created on BitBucket, and all those interested can use that. 
Later on if the work in these forks is to be reintegrated into the master repository, the changes can be either 
submitted as a patch or (preferably) the changes pulled across with the full commit history, if that makes sense. 

Everyday Tasks
~~~~~~~~~~~~~~

Committing
^^^^^^^^^^

General Principles
++++++++++++++++++

*Testing:* Mercurial allows you to commit locally, which means you have a faster workflow. However, as a core developer who will be pushing changes
to the master, you should still try to ensure that all your commits are consistent in themselves, that is that evey point in the history
of the repository builds and runs. It 'is' possible to re-shuffle the commits you've made later using Mercurial Queues, 'but only' if
you haven't pushed the commits anywhere else beforehand. Usually it's better to try to keep your commits consistent all the time. So, *do* commit
often, because a rich history is always best, but do at least check that everything compiles and runs before creating a new commit. 

*Cohesive commits:* Your commits should be as focussed as possible on a single subject. Try not to commit changes for multiple purposes at once, it
makes it much more difficult to pick apart those changes later if needed. And most importantly, never 'ever' commit a bugfix and a feature 
change in one commit, unless changing the feature was the only way to fix the bug (in which case it can only be fixed in the unstable default branch). 

*Unnecessary changes:* Although it can be tempting to "tidy" code, fix indenting, standardise etc, you should generally avoid doing this for its own sake. 
If you're changing the code anyway, by all means fix any formatting and standardisation issues in the area in question while you're at it. But purely 
aesthetic changes should never be committed on their own, because all of them can potentially make merging 'real' changes - across branches and
accepting patches - far more difficult because of conflicts caused simply by trivial formatting changes. 

Committing Bugfixes
+++++++++++++++++++

Bugfixes should always be committed to the 'current stable branch' (assuming they affect it) first. So for example at the time of writing
bugfixes should be committed to the v1-7 branch. These bugfixes will be merged forwards into the default branch periodically. The reasons for 
committing to the stable branch first and merging forward, as opposed to committing to the default branch and picking commits to transplant back to the 
stable branch, are many:
* It encourages primary testing and early committing on the stable branch, which is where fixes are most needed most urgently anyway.
* Merge conflicts always happen in the unstable branch, not the stable branch. This is better again because the stable branch is the most important to keep as clean as possible
* Merging is automatic. You always want to merge ALL changes from the stable branch into the default branch, there is no human error involved in selecting what changes to merge. If you cherry-pick fixes to port to the stable branch, you have to make sure you don't miss anything, make sure you don't accidentally include an interface change, etc. And if someone has committed a combined fix and an API change in one commit (see below) it's a mess.

Committing New Features and Breaking Changes
++++++++++++++++++++++++++++++++++++++++++++

Any new feature, or a change which changes either the API or the behaviour within the existing API, must always be committed to the default branch (often referred to as 'unstable'). 

Pushing / Pulling
~~~~~~~~~~~~~~~~~

Pushing and pulling is how you get commits to and from remote repositories, respectively. This is mostly covered in the Mercurial tutorials.

However, a common occurrence is that you try to push your commits to the master, but find that you get an error saying "abort: push creates new remote heads!". 
This is a bit of a confusing message, but basically it means that someone else pushed their commits before you did, and you're not allowed to push your
changes until you've resolved this. 

The http://hginit.com[HG Init] tutorials suggest resolving this by pulling and then merging the changes with your own, which is indeed the standard way
to handle this, but it has one major drawback - every time it happens, in the history you have a permanent record of this divergence in the form of a 
branch and merge of the 2 developers changes. This is extremely distracting when trying to decipher the history. 

So, it is at this point that the Rebase extension comes into play, which is why I advised you to enable it. With this, after pulling the changes from 
the master (and ending up with 2 heads on your branch), instead of merging them, you 'rebase' your own commits so that they are re-applied on top of the 
head you pulled from the master, essentially flattening the history, eliminating the branch and removing the need for a merge. 

It's generally best to do this when you pull:

--------------------------------------
hg pull --rebase
--------------------------------------

But, if you forget and you've already pulled the changes you can use the explicit rebase command:

--------------------------------------
hg rebase 
--------------------------------------

If you're using TortoiseHg, you can make Rebase the default option to use when pulling, which is highly recommended, by 
doing this in your configuration file:

--------------------------------------
[tortoisehg]
postpull = rebase
--------------------------------------

It's possible for the rebase to fail, for example if there are conflicting changes. If this happens, you essentially have to resolve the conflicts 
in your working copy and commit them.

Merging Bugfixes
~~~~~~~~~~~~~~~~

TODO

Transplanting Individual Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO



