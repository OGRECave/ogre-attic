OGRE Developer Guide
====================
Steve Streeting <sinbad@ogre3d.org>
v1.0, 11 March 2010

This document sets out the principles under which OGRE development will be undertaken, 
and is designed to be used as an introduction for new developers, and a reference for
existing developers. 

NOTE: While this document is primarily aimed at core developers and other contributors to OGRE, 
regular users might find it interesting too, particularly if they aspire to contribute code eventually.

Recommended Mercurial Configuration
-----------------------------------
OGRE uses Mercurial for source control, this is a Distributed Version Control System (DVCS), which means that
while there is a central repository which is considered 'authorative', in fact everyone is able to clone their own
copy of the repository and commit to it themselves too, with changes being exchanged by 'pushing' and 'pulling' changesets
(commits) between repository clones. 

For an introduction to Mercurial, please read http://mercurial.selenic.com/wiki/Tutorial[the official Mercurial tutorials] or
http://hginit.com[Joel Spolsky's tutorials]. However, please note particularly in the case of the latter that the OGRE team's
recommeded approach to using Mercurial differs slightly, with respect to the following cases:
* How to resolve the case where another user pushed their changes to the master before you
* How stable version branches are handled

So please keep that in mind. This document will not teach you the basics of using Mercurial since other documents do that already, 
but we will cover recommended configurations for OGRE and accepted approaches to common issues.

There are some common settings that you should have set in your Mercurial configuration, which can be made globally
in ~/.hgrc on Linux and Mac OS X, or C:\Documents and Settings\'User'\mercurial.ini on Windows. 

UI Section
~~~~~~~~~~

User name
^^^^^^^^^

At the very minimum, you need to define your user name and email address, which identifies you:
------------------------------------------------------------
[ui]
username = Joe Bloggs <joe@bloggs.com>
------------------------------------------------------------

Ignore List
^^^^^^^^^^^

Also in this section, you're likely to want to define a global ignore list, so that you don't have to 
configure ignored files per repository. For example:
------------------------------------------------------------
[ui]
username = Joe Bloggs <joe@bloggs.com>
ignore=c:\hgignore_global.txt
------------------------------------------------------------

So here (on Windows) I'm referencing an ignore list file I've created at c:\hgignore_global.txt. 
A pretty good start for a global ignore list might look like this:

------------------------------------------------------------
syntax: glob 

*~
*.orig
*.rej
*.swp 
.#* 
*.obj 
*.o
*.a
*.ncb 
*.ilk 
*.exe 
*.dll 
*.lib 
*.manifest 
*.pdb 
*.idb 
*.rsp 
*.pch 
*.dep
*.so
*.dylib
*.framework
------------------------------------------------------------
You can obviously add more elements to that if you wish. 

Extensions
~~~~~~~~~~

We recommend enabling a few Mercurial extensions for OGRE development; this is done quite simply in the configuration file. 

Common Extensions
^^^^^^^^^^^^^^^^^
Your configuration file should include at least the following:

------------------------------------------------------------
[extensions]
progress=
rebase=
transplant=
------------------------------------------------------------
The Progress extension just gives you more feedback on the progress of operations. 

The Rebase extension allows you re-apply your commits on top of changes in the master repository, when someone else
has pushed their changes to the master before you have. This avoids having to explicitly merge your changes with theirs, keeping a 
messy history; it effectively looks as if you had applied your changes on top of their in the first place. See <<Pulling,Pulling Changesets>>.

The Transplant extension allows you to pull individual commits from one branch to another, should you need to.
Typically changes are merged between branches but occasionally there are cases where you need to transplant individual ones.

[[HgCfgDiff]]
Diff settings
^^^^^^^^^^^^^

Mercurial can generate patches in 2 different forms:- the default patch format is compatible with the GNU patch utilities and any other tools that understand them, and is
therefore very portable; however it cannot deal with binary files, and can't cope with renames. To resolve this, Mercurial also
supports the Git patch format, which embeds more information and can also handle binaries. This is the *recommended* patch format for OGRE since it is far more functional, although it
means you have to use Mercurial itself to apply the patches. 
------------------------------------------------------------
[diff]
git = True
------------------------------------------------------------

Windows Text Handling
^^^^^^^^^^^^^^^^^^^^^
Because Windows handles line endings differently to Linux and OS X, you will need some extra entries in your configuration:

------------------------------------------------------------
# inside [extensions]
hgext.win32text=

[encode]
** = cleverencode:
[decode]
** = cleverdecode:
[hooks]
# Reject commits which would introduce windows-style text files
pretxncommit.crlf = python:hgext.win32text.forbidcrlf
------------------------------------------------------------

This is 'very important' - by default Mercurial performs no line-ending conversion. By enabling the win32text 
extension, you cause all text files to be converted to Unix line endings before commit, and converted to Windows
line endings when your working copy is updated. This keeps everything consistent. 

The cleverencode and cleverdecode entries determine whether a file is text by looking to see if
there are any NUL characters in the file; if there are none, it is assumed to be text, if there are one or
more NULs then it's considered to be binary.

The hook defined at the bottom is included to prevent accidental committing of files with remaining Windows line feeds. 

[[THGConfig]]
TortoiseHg Specific
^^^^^^^^^^^^^^^^^^^

If you're using http://tortoisehg.bitbucket.org/[TortoiseHg], you definitely want to set the following option:
------------------------------------------------------------
[tortoisehg]
postpull = rebase
------------------------------------------------------------

This sets the default action after pulling changesets to rebase your own outstanding changesets on top of it. You can 
also find it in the Global Options under Synchronize > After Pull Operation.

Using Mercurial
---------------

Hopefully you're familiar with the basic principles of using Mercurial already; if not, please revisit the 
http://mercurial.selenic.com/wiki/Tutorial[the official Mercurial tutorials]. However, Mercurial is very flexible 
so some ground rules need to be established in order for the team to stay organised.

General Points
~~~~~~~~~~~~~~

Master Repository
^^^^^^^^^^^^^^^^^
The ''master'' repository is located on BitBucket here: http://bitbucket.org/sinbad/ogre/ . I recommend that developers
use the SSH link (with SSH keys if you like) rather than https, because it's more reliable when doing large transactions
because the timeout is far larger.

Official Branches
^^^^^^^^^^^^^^^^^
The master repository will use branches 'only' for official development streams, which in practice means one branch per major stable version, 
plus the default branch (which is considered "unstable"). For example, this might be the list of branches in the master repository:

-----------------------------------------
default
v1-7
v1-6
-----------------------------------------

NOTE: When we were using Subversion, we used branches for other purposes too such as experimental work by a core team member which was uncertain 
for official inclusion, or a student project on Google Summer of Code - we will no longer use branches for these things. 
Instead all other divergences in the code will be handled by making 'clones' of the repository and not by 
branches. If these clones need to be public, then a fork should be created on BitBucket, and all those interested can use that. 
Later on if the work in these forks is to be reintegrated into the master repository, the changes can be either 
submitted as a patch or (preferably) the changes pulled across with the full commit history, if that makes sense. 

Everyday Tasks
~~~~~~~~~~~~~~

Committing
^^^^^^^^^^

General Principles
++++++++++++++++++

*Testing:* Mercurial allows you to commit locally, which means you have a faster workflow. However, as a core developer who will be pushing changes
to the master, you should still try to ensure that all your commits are consistent in themselves, that is that evey point in the history
of the repository builds and runs. It 'is' possible to re-shuffle the commits you've made later using Mercurial Queues, 'but only' if
you haven't pushed the commits anywhere else beforehand. Usually it's better to try to keep your commits consistent all the time. So, *do* commit
often, because a rich history is always best, but do at least check that everything compiles and runs before creating a new commit. 

*Cohesive commits:* Your commits should be as focussed as possible on a single subject. Try not to commit changes for multiple purposes at once, it
makes it much more difficult to pick apart those changes later if needed. And most importantly, never 'ever' commit a bugfix and a feature 
change in one commit, unless changing the feature was the only way to fix the bug (in which case it can only be fixed in the unstable default branch). 

*Unnecessary changes:* Although it can be tempting to "tidy" code, fix indenting, standardise etc, you should generally avoid doing this for its own sake. 
If you're changing the code anyway, by all means fix any formatting and standardisation issues in the area in question while you're at it. But purely 
aesthetic changes should never be committed on their own, because all of them can potentially make merging 'real' changes - across branches and
accepting patches - far more difficult because of conflicts caused simply by trivial formatting changes. 

Committing Bugfixes
+++++++++++++++++++

Bugfixes should always be committed to the 'current stable branch' (assuming they affect it) first. So for example at the time of writing
bugfixes should be committed to the v1-7 branch. These bugfixes will be merged forwards into the default branch periodically. The reasons for 
committing to the stable branch first and merging forward, as opposed to committing to the default branch and picking commits to transplant back to the 
stable branch, are many:
* It encourages primary testing and early committing on the stable branch, which is where fixes are most needed most urgently anyway.
* Merge conflicts always happen in the unstable branch, not the stable branch. This is better again because the stable branch is the most important to keep as clean as possible
* Merging is automatic. You always want to merge ALL changes from the stable branch into the default branch, there is no human error involved in selecting what changes to merge. If you cherry-pick fixes to port to the stable branch, you have to make sure you don't miss anything, make sure you don't accidentally include an interface change, etc. And if someone has committed a combined fix and an API change in one commit (see below) it's a mess.

Committing New Features and Breaking Changes
++++++++++++++++++++++++++++++++++++++++++++

Any new feature, or a change which changes either the API or the behaviour within the existing API, must always be committed to the default branch (often referred to as 'unstable'). 

Pushing / Pulling
~~~~~~~~~~~~~~~~~

Pushing and pulling is how you get commits to and from remote repositories, respectively. This is mostly covered in the Mercurial tutorials & documentation. 
This section is concerned with the recommended approach to common issues.

Pushing Changesets
^^^^^^^^^^^^^^^^^^

This is very easy to do, you can use 'hg outgoing' and 'hg push' (or the GUI equivalent) to send the changesets (commits) you've already made to the master - the default remote will be
the master if you cloned from it originally, otherwise you can define other aliases in REPO_ROOT/.hg/hgrc.

However, a common occurrence is that you try to push your commits to the master, but find that you get an error saying:
------------------------------------------------------------------
abort: push creates new remote heads!
(did you forget to merge? use push -f to force)
------------------------------------------------------------------

This is a bit of a confusing message, but the most common reason it means that someone else pushed their commits before you did, and you're not allowed to push your
changes until you've resolved this. The 'new remote heads' refers to the fact that you would effectively create 2 different parallel streams of development on the
branch in question, and you can't (or rather, shouldn't) push that, although you might do it locally. 

The advice "(did you forget to merge? use push -f to force)" is not a great tip either. You almost never want to use push -f, and actually in the most common case
of being out of date with upstream changes, there's a better option than merging - see <<Pulling>> below for details. 

If you've actually created multiple heads for a branch locally - which you may have done deliberately by committing 2 sets of parallel changes from the same base, 
or because you've pulled or imported someone elses changes which were based on an earlier revision, your choices are how to unify those before pushing. See <<ParallelDev,Parallel Development>>
for more details. 

[[Pulling]]
Pulling Changesets
^^^^^^^^^^^^^^^^^^

Pulling changesets from the master (usually the default) or other repositories is easy to do (hg incoming to preview, hg pull to do it), but it's
important to understand the effects of parallel development. 

For now, let's just say that you always want to use the rebase extension when you pull:
--------------------------------------
hg pull --rebase
--------------------------------------

If you forget to use --rebase, it's no big deal because you can rebase later too, but definitely try to remember to use it because it's simpler. 
In TortoiseHg you can set is as the default option, see <<THGConfig,TortoiseHg config options>> for details.

For more on this, see <<ParallelDev,Parallel Development>>.

Dealing With Patches
~~~~~~~~~~~~~~~~~~~~

Although you can pull changes directly from other people's repositories too, and this may the best way to handle very large external contributions such as reintegrating 
forks, generally external contributions are still handled via patches. There's a difference between patches in Mercurial and patches for Subversion or CVS though, because patches 
in centralised systems are always a one-shot deal of a working copy compared against a single upstream version. In Mercurial, because contributors can commit locally, patches are actually exported 
changesets, with a full commit history. This fine grained change information can make patches easier to integrate, but it also comes with some added considerations. We'll 
talk about generating and consuming patches in this section.

Generating Patches
^^^^^^^^^^^^^^^^^^

As mentioned above, in Mercurial you generate patches from your local commits. This is quite simple:
-------------------------------------------------------------
hg export --git -o %b_patch%nof%N_%h.patch REVS
-------------------------------------------------------------

Replace REVS with a list of revisions, or a range such as REV1:REV2. It will create one file per changeset named something like ogre_patch1of2_f0c47360a828.diff. You should zip them 
up and send them to the patch list. 

NOTE: Although it's possible to just pipe the output from hg export to a single file for multiple changesets, and this does work, this is generally not recommended, because a failure to import one
of the patches will cause the entire file to fail. 

NOTE: If you've configured Mercurial the way we recommended in the <<HgCfgDiff,Mercurial configuration section>>, the --git is unecessary because it's the default,
but it's included for completeness. 

NOTE: The PatchBomb extension can be used to email many patches at once, but its reliance on email (and thus mailing lists) makes it not that useful to us, since
we use a dedicated patch list.

NOTE: Mercurial Queues (MQ) allows vastly more complex handling of patches, particularly for those wanting to keep track of non-core alterations and to consolidate
sets of commits into a smaller list for submission upstream. You can read about them in the http://hgbook.red-bean.com/read/managing-change-with-mercurial-queues.html[Mercurial Manual].
We won't talk about MQ here because it isn't needed unless your requirements are fairly complex.

Applying Patches
^^^^^^^^^^^^^^^^

Applying patches is also fairly simple in itself, but there are a couple of nuances. Here's the standard command:
-------------------------------------------------------------
hg import PATCH_FILES...
-------------------------------------------------------------
It doesn't matter whether the patch file is in GNU style or Git style, it will work either way. But it's important to understand what this does - each patch file (usually) contains
a single commit, and those commits are applied on top of your current repository, on to your current branch. Unlike a patch for Subversion, which applies to your working copy which 
you then need to commit, this actually transfers commits directly, including the original author names & emails. 

Because it tries to apply the commits in the patch to the current base, failures are possible if conflicting changes have occurred. In this case, hg import just aborts. A good way to 
deal with this is to use the --exact parameter, which then applies the changes to the revision that is listed as the base in the patch file (which should therefore always succeed unless
the patch is broken). This will create one or more new heads on the branch in question which you should then merge or rebase into your own branch, resolving the conflicts as appropriate. 
See <<ParallelDev,Parallel Development>> for more information.


[[ParallelDev]]
Parallel Development
~~~~~~~~~~~~~~~~~~~~~

Because a commit in Mercurial always knows what changeset it was parented from, if you pull changes into your local repository (or import a patch using the --exact option), they are by default applied
as differences against the base changeset they were originally made against. If you already have changes on the branch in question after this parent changeset, this effectively
creates a divergence in the history:
 
image:images/hgmultipleheads1.png[height=200]

In this case the green revisions are your changes, and the orange ones are those you have just pulled from the master (in the case of hg import --exact, the green revisions would be the contents of the patch). 

The http://hginit.com[HG Init] tutorials suggest resolving this by merging the changes with your own, which is indeed the standard no-extension way
to handle this, but it has one major drawback - every time it happens, in the history you have a permanent record of this divergence in the form of a 
split and merge of the 2 developers changes. This is extremely distracting when trying to decipher the history. 

Instead, by using the Rebase extension, after pulling changes you 'rebase' your own commits so that they are re-applied on top of the 
head you pulled from the master, essentially flattening the history, like this: 

image:images/hgmultipleheads2.png[height=300]

You can do this during the pull by appending the --rebase command (or selecting it in TortoiseHg):
-------------------------------------------------------------
hg pull --rebase
-------------------------------------------------------------
However if you've already got the divergence in your repository, you can rebase specifically:
-------------------------------------------------------------
hg rebase --continue
-------------------------------------------------------------
The "--continue" means that any conflicts will be resolved in your working copy, which will then need committing.

Rebase is usually automatic in the common case where the divergence has been caused by pulling from the master, but if they've occurred for another reason (e.g. hg import --exact) then you may need to explictly specify the rebase options. For example, in the example image, the specific command for performing the rebase is:
-------------------------------------------------------------
hg rebase -s492385cab361 -da638fcd23823 --continue
-------------------------------------------------------------
You could use the Mercurial short revision numbers instead of the "short" hashes there, but the principle is that you're moving the base of the green revisions to the top of the orange ones. You very rarely need to use this explicit form, but that's how you do it if you need to.

Merging Bugfixes
~~~~~~~~~~~~~~~~

The case where you will want to use the merge command is when merging bugfixes in the stable branch (currently v1-7) into the default (unstable) branch. This is very simple in Mercurial; if we assume we're in a working copy which is on the head of the default branch:
-------------------------------------------------------------
hg merge v1-7
-------------------------------------------------------------
Changes will be merged into your working copy along with parent metadata tracking the merge. If there are conflicts, you'll have to resolve them in your working copy before you commit. 
Once you've done this and tested the merge, you should commit it. You don't need to specify much detail in the merge commit (just 'Merged from v1-7' or similar) because the 
changeset metadata gives enough information to track which changesets are included in the merge.

TIP: Even on Windows, I strongly recommend using KDiff3 (included with TortoiseHg) to resolve conflicts and not WinMerge or TortoiseMerge. The reason is that when using a graphical diff tool, conflicts are handled in Mercurial by keeping separate files rather than embedding the "chevron markers" inside the main file. When Mercurial delegates the merge to the GUI tool, it assumes you resolved the problem when you exit - and the problem with WinMerge is that it doesn't give you any warning if you exit without resolving the problem (often leaving you with a file which has not merged either of the conflicting changes into it, so you lose changes!). KDiff3 however warns you if you try to exit without resolving every conflict. 

Transplanting Individual Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO

Backing out a change
~~~~~~~~~~~~~~~~~~~~

TODO

Using Bisect to Track Down Breakages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO