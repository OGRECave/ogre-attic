<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on , 4 2003 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>OGRE Manual: Texture Units</TITLE>

<META NAME="description" CONTENT="OGRE Manual: Texture Units">
<META NAME="keywords" CONTENT="OGRE Manual: Texture Units">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">
<LINK TYPE="text/css" rel="stylesheet" href="../style.css"> 
</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC48"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_18.html#SEC30"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_16.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_20.html#SEC69"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H3> 3.1.3 Texture Units </H3>
<!--docid::SEC48::-->

Here are the attributes you can use in a 'texture_unit' section of a .material script:

<A NAME="SEC49"></A>
<H2> Available Texture Layer Attributes </H2>
<!--docid::SEC49::-->
<UL>
<LI>
<A HREF="manual_19.html#SEC51">texture</A>
<LI>
<A HREF="manual_19.html#SEC52">anim_texture</A>
<LI>
<A HREF="manual_19.html#SEC53">cubic_texture</A>
<LI>
<A HREF="manual_19.html#SEC54">tex_coord_set</A>
<LI>
<A HREF="manual_19.html#SEC55">tex_address_mode</A>
<LI>
<A HREF="manual_19.html#SEC56">filtering</A>
<LI>
<A HREF="manual_19.html#SEC57">colour_op</A>
<LI>
<A HREF="manual_19.html#SEC58">alpha_rejection</A>
<LI>
<A HREF="manual_19.html#SEC59">colour_op_ex</A>
<LI>
<A HREF="manual_19.html#SEC60">colour_op_multipass_fallback</A>
<LI>
<A HREF="manual_19.html#SEC61">alpha_op_ex</A>
<LI>
<A HREF="manual_19.html#SEC62">env_map</A>
<LI>
<A HREF="manual_19.html#SEC63">scroll</A>
<LI>
<A HREF="manual_19.html#SEC64">scroll_anim</A>
<LI>
<A HREF="manual_19.html#SEC65">rotate</A>
<LI>
<A HREF="manual_19.html#SEC66">rotate_anim</A>
<LI>
<A HREF="manual_19.html#SEC67">scale</A>
<LI>
<A HREF="manual_19.html#SEC68">wave_xform</A>
</UL>

<A NAME="SEC50"></A>
<H2> Attribute Descriptions  </H2>
<!--docid::SEC50::-->
<A NAME="texture"></A>
<A NAME="SEC51"></A>
<H3> texture </H3>
<!--docid::SEC51::-->

Sets the name of the static texture image this layer will use.<BR><BR>

Format: texture &#60;texturename&#62;<BR><BR>

Example: texture funkywall.jpg<BR><BR>

This setting is mutually exclusive with the anim_texture attribute. Note that the texture file cannot include spaces. Those of you Windows users who like spaces in filenames, please get over it and use underscores instead.<BR><BR>

Default: none<BR><BR>

<A NAME="anim_texture"></A>
<A NAME="SEC52"></A>
<H3> anim_texture </H3>
<!--docid::SEC52::-->

Sets the images to be used in an animated texture layer. In this case an animated texture layer means one which has multiple frames, each of which is a separate image file. There are 2 formats, one for implicitly determined image names, one for explicitly named images.<BR><BR>

Format1 (short): anim_texture &#60;base_name&#62; &#60;num_frames&#62; &#60;duration&#62;<BR><BR>

Example: anim_texture flame.jpg 5 2.5<BR><BR>

This sets up an animated texture layer made up of 5 frames named flame_1.jpg, flame_2.jpg etc, with an animation length of 2.5 seconds (2fps). If duration is set to 0, then no automatic transition takes place and frames must be changed manually in code.<BR><BR>

Format2 (long): anim_texture &#60;frame1&#62; &#60;frame2&#62; ... &#60;duration&#62;<BR><BR>

Example: anim_texture flamestart.jpg flamemore.png flameagain.jpg moreflame.jpg lastflame.tga 2.5<BR><BR>

This sets up the same duration animation but from 5 separately named image files. The first format is more concise, but the second is provided if you cannot make your images conform to the naming standard required for it. <BR><BR>

Default: none<BR><BR>

<A NAME="cubic_texture"></A>
<A NAME="SEC53"></A>
<H3> cubic_texture </H3>
<!--docid::SEC53::-->

Sets the images used in a cubic texture, i.e. one made up of 6 individual images making up the faces of a cube. These kinds of textures are used for reflection maps (if hardware supports cubic reflection maps) or skyboxes. There are 2 formats, a brief format expecting image names of a particular format and a more flexible but longer format for arbitrarily named textures.<BR><BR>

Format1 (short): cubic_texture &#60;base_name&#62; &#60;combinedUVW|separateUV&#62;<BR><BR>

The base_name in this format is something like 'skybox.jpg', and the system will expect you to provide skybox_fr.jpg, skybox_bk.jpg, skybox_up.jpg, skybox_dn.jpg, skybox_lf.jpg, and skybox_rt.jpg for the individual faces.<BR><BR>

Format2 (long): cubic_texture &#60;front&#62; &#60;back&#62; &#60;left&#62; &#60;right&#62; &#60;up&#62; &#60;down&#62; &#60;combinedUVW|separateUV&#62;<BR><BR>

In this case each face is specified explicitly, incase you don't want to conform to the image naming standards above.<BR><BR>

In both cases the final parameter means the following:
<DL COMPACT>
<DT>combinedUVW
<DD>	The 6 textures are combined into a single 'cubic' texture map which is then addressed using 3D texture coordinates with U, V and W components. Necessary for reflection maps since you never know which face of the box you are going to need. Note that not all cards support cubic environment mapping.
<DT>separateUV
<DD>	The 6 textures are kept separate but are all referenced by this single texture layer. One texture at a time is active (they are actually stored as 6 frames), and they are addressed using standard 2D UV coordinates. This type is good for skyboxes since only one face is rendered at one time and this has more guaranteed hardware support on older cards.
</DL>
<BR>
Default: none

<A NAME="tex_coord_set"></A>
<A NAME="SEC54"></A>
<H3> tex_coord_set </H3>
<!--docid::SEC54::-->

Sets which texture coordinate set is to be used for this texture layer. A mesh can define multiple sets of texture coordinates, this sets which one this material uses.<BR><BR>

Format: tex_coord_set &#60;set_num&#62;<BR><BR>

Example: tex_coord_set 2<BR><BR>

Default: tex_coord_set 0<BR><BR>

<A NAME="tex_address_mode"></A>
<A NAME="SEC55"></A>
<H3> tex_address_mode </H3>
<!--docid::SEC55::-->
Defines what happens when texture coordinates exceed 1.0 for this texture layer.<BR><BR>

Format: tex_address_mode &#60;wrap|clamp|mirror&#62;
<DL COMPACT>
<DT>wrap
<DD>	Any value beyond 1.0 wraps back to 0.0. Texture is repeated.
<DT>clamp
<DD>	Values beyond 1.0 are clamped to 1.0. Texture 'streaks' beyond 1.0 since last line of pixels is used across the rest of the address space. Useful for textures which need exact coverage from 0.0 to 1.0 without the 'fuzzy edge' wrap gives when combined with filtering.
<DT>mirror
<DD>	Texture flips every boundary, meaning texture is mirrored every 1.0 u or v
</DL>
<BR>
Default: tex_address_mode wrap<BR><BR>

<A NAME="filtering"></A>
<A NAME="SEC56"></A>
<H3> filtering </H3>
<!--docid::SEC56::-->

Sets the type of texture filtering used when magnifying or minifying a texture.<BR><BR>

Format: filtering &#60;none|bilinear|trilinear&#62;<BR><BR>

Default: filtering bilinear<BR><BR>

<A NAME="colour_op"></A>
<A NAME="SEC57"></A>
<H3> colour_op </H3>
<!--docid::SEC57::-->

Determines how the colour of this texture layer is combined with the one below it (or the lighting effect on the geometry if this is the first layer).<BR><BR>

Format: colour_op &#60;replace|add|modulate|alpha_blend&#62;<BR><BR>

This method is the simplest way to blend texture layers, because it requires only one parameter, gives you the most common blending types, and automatically sets up 2 blending methods: one for if single-pass multitexturing hardware is available, and another for if it is not and the blending must be achieved through multiple rendering passes. It is, however, quite limited and does not expose the more flexible multitexturing operations, simply because these can't be automatically supported in multipass fallback mode. If want to use the fancier options, use <A HREF="manual_19.html#SEC59">colour_op_ex</A>, but you'll either have to be sure that enough multitexturing units will be available, or you should explicitly set a fallback using <A HREF="manual_19.html#SEC60">colour_op_multipass_fallback</A>.<BR>
<DL COMPACT>
<DT>replace
<DD>	Replace all colour with texture with no adjustment.
<DT>add
<DD>	Add colour components together.
<DT>modulate
<DD>	Multiply colour components together.
<DT>alpha_blend
<DD>	Blend based on texture alpha.
</DL>
<BR>
Default: colour_op modulate

<A NAME="alpha_rejection"></A>
<A NAME="SEC58"></A>
<H3> alpha_rejection </H3>
<!--docid::SEC58::-->

Sets the way the layer will have use alpha to totally reject pixels from the pipeline.<BR><BR>

Format: alpha_rejection &#60;function&#62; &#60;value&#62;<BR><BR>

Example: alpha_rejection greater_equal 128<BR><BR>

The function parameter can be any of the options listed in the material depth_function attribute. The value parameter can theoretically be any value between 0 and 255, but is best limited to 0 or 128 for hardware compatibility.<BR><BR>

Default: alpha_rejection always_pass<BR><BR>

<A NAME="colour_op_ex"></A>
<A NAME="SEC59"></A>
<H3> colour_op_ex </H3>
<!--docid::SEC59::-->

This is an extended version of the <A HREF="manual_19.html#SEC57">colour_op</A> attribute which allows extremely detailed control over the blending applied between this and earlier layers. Multitexturing hardware can apply more complex blending operations that multipass blendind, but you are limited to the number of texture units which are available in hardware.<BR><BR>

Format: colour_op_ex &#60;operation&#62; &#60;source1&#62; &#60;source2&#62; [&#60;manual&#62;]<BR><BR>

Example colour_op_ex add_signed src_manual src_current 0.5<BR><BR>

See the IMPORTANT note below about the issues between mulitpass and multitexturing that using this method can create. Texture colour operations determine how the final colour of the surface appears when rendered. Texture units are used to combine colour values from various sources (e.g. the diffuse colour of the surface from lighting calculations, combined with the colour of the texture). This method allows you to specify the 'operation' to be used, i.e. the calculation such as adds or multiplies, and which values to use as arguments, such as a fixed value or a value from a previous calculation.<BR><BR>

<DL COMPACT>
<DT>Operation options
<DD><DL COMPACT>
<DT>source1
<DD>	Use source1 without modification
<DT>source2
<DD>	Use source2 without modification
<DT>modulate
<DD>	Multiply source1 and source2 together.
<DT>modulate_x2
<DD>	Multiply source1 and source2 together, then by 2 (brightening).
<DT>modulate_x4
<DD>	Multiply source1 and source2 together, then by 4 (brightening).
<DT>add
<DD>	Add source1 and source2 together.
<DT>add_signed
<DD>	Add source1 and source2 then subtract 0.5.
<DT>add_smooth
<DD>	Add source1 and source2, subtract the product
<DT>subtract
<DD>	Subtract source2 from source1
<DT>blend_diffuse_alpha
<DD>	Use interpolated alpha value from vertices to scale source1, then add source2 scaled by (1-alpha).
<DT>blend_texture_alpha
<DD>	As blend_diffuse_alpha but use alpha from texture
<DT>blend_current_alpha
<DD>	As blend_diffuse_alpha but use current alpha from previous stages (same as blend_diffuse_alpha for first layer)
<DT>blend_manual
<DD>	As blend_diffuse_alpha but use a constant manual alpha value specified in &#60;manual&#62;
</DL>
<DT>Source1 and source2 options
<DD><DL COMPACT>
<DT>src_current
<DD>	The colour as built up from previous stages.
<DT>src_texture
<DD>	The colour derived from the texture assigned to this layer.
<DT>src_diffuse
<DD>	The interpolated diffuse colour from the vertices (same as 'src_current' for first layer).
<DT>src_specular
<DD>	The interpolated specular colour from the vertices.
</DL>
</DL>
<BR>
For example 'modulate' takes the colour results of the previous layer, and multiplies them with the new texture being applied. Bear in mind that colours are RGB values from 0.0-1.0 so multiplying them together will result in values in the same range, 'tinted' by the multiply. Note however that a straight multiply normally has the effect of darkening the textures - for this reason there are brightening operations like modulate_x2. Note that because of the limitations on some underlying APIs (Direct3D included) the 'texture' argument can only be used as the first argument, not the second. <BR><BR>

Note that the last parameter is only required if you decide to pass a value manually into the operation. Hence you only need to fill these in if you use the 'blend_manual' operation.<BR><BR>

IMPORTANT: Ogre tries to use multitexturing hardware to blend texture layers together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object multiple times with different textures. This is both less efficient and there is a smaller range of blending operations which can be performed. For this reason, if you use this method you really should set the colour_op_multipass_fallback attribute to specify which effect you want to fall back on if sufficient hardware is not available (the default is just 'modulate' which is unlikely to be what you want if you're doing swanky blending here). If you wish to avoid having to do this, use the simpler colour_op attribute which allows less flexible blending options but sets up the multipass fallback automatically, since it only allows operations which have direct multipass equivalents.<BR><BR>

Default: none (colour_op modulate)<BR>

<A NAME="colour_op_multipass_fallback"></A>
<A NAME="SEC60"></A>
<H3> colour_op_multipass_fallback </H3>
<!--docid::SEC60::-->

Sets the multipass fallback operation for this layer, if you used colour_op_ex and not enough multitexturing hardware is available.<BR><BR>

Format: colour_op_multipass_fallback &#60;src_factor&#62; &#60;dest_factor&#62;<BR><BR>

Example: colour_op_mulitpass_fallback one one_minus_dest_alpha<BR><BR>

Because some of the effects you can create using colour_op_ex are only supported under multitexturing hardware, if the hardware is lacking the system must fallback on multipass rendering, which unfortunately doesn't support as many effects. This attribute is for you to specify the fallback operation which most suits you.<BR><BR>

The parameters are the same as in the scene_blend attribute; this is because multipass rendering IS effectively scene blending, since each layer is rendered on top of the last using the same mechanism as making an object transparent, it's just being rendered in the same place repeatedly to get the multitexture effect. If you use the simpler (and less flexible) colour_op attribute you don't need to call this as the system sets up the fallback for you.<BR><BR>

<A NAME="alpha_op_ex"></A>
<A NAME="SEC61"></A>
<H3> alpha_op_ex </H3>
<!--docid::SEC61::-->

Behaves in exactly the same away as <A HREF="manual_19.html#SEC59">colour_op_ex</A> except that it determines how alpha values are combined between texture layers rather than colour values.

<A NAME="env_map"></A>
<A NAME="SEC62"></A>
<H3> env_map </H3>
<!--docid::SEC62::-->

Turns on/off texture coordinate effect that makes this layer an environment map.<BR><BR>

Format: env_map &#60;off|spherical|planar|cubic&#62;<BR><BR>

Environment maps make an object look reflective by using automatic texture coordinate generation depending on the relationship between the objects vertices or normals and the eye.<BR><BR>
<DL COMPACT>
<DT>spherical
<DD>	A spherical environment map. Requires a single texture which is either a fish-eye lens view of the reflected scene, or some other texture which looks good as a spherical map (a texture of glossy highlights is popular especially in car sims). This effect is based on the relationship between the eye direction and the vertex normals of the object, so works best when there are a lot of gradually changing normals, i.e. curved objects.
<DT>planar
<DD>	Similar to the spherical environment map, but the effect is based on the position of the vertices in the viewport rather than vertex normals. This effect is therefore useful for planar geometry (where a spherical env_map would not look good because the normals are all the same) or objects without normals.
<DT>cubic
<DD>	A more advanced form of reflection mapping which uses a group of 6 textures making up the inside of a cube, each of which is a view if the scene down each axis. Works extremely well in all cases but has a higher technical requirement from the card than spherical mapping.
</DL>
<BR>
Default: env_map off<BR>

<A NAME="scroll"></A>
<A NAME="SEC63"></A>
<H3> scroll </H3>
<!--docid::SEC63::-->


Sets a fixed scroll offset for the texture.<BR><BR>

Format: scroll &#60;x&#62; &#60;y&#62;<BR><BR>

This method offsets the texture in this layer by a fixed amount. Useful for small adjustments without altering texture coordinates in models. However if you wish to have an animated scroll effect, see the <A HREF="manual_19.html#SEC64">scroll_anim</A> attribute.<BR><BR>

<A NAME="scroll_anim"></A>
<A NAME="SEC64"></A>
<H3> scroll_anim </H3>
<!--docid::SEC64::-->

Sets up an animated scroll for the texture layer. Useful for creating fixed-speed scrolling effects on a texture layer (for varying scroll speeds, see <A HREF="manual_19.html#SEC68">wave_xform</A>).<BR><BR>

Format: scroll_anim &#60;xspeed&#62; &#60;yspeed&#62;<BR>

<A NAME="rotate"></A>
<A NAME="SEC65"></A>
<H3> rotate </H3>
<!--docid::SEC65::-->

Rotates a texture to a fixed angle. This attribute changes the rotational orientation of a texture to a fixed angle, useful for fixed adjustments. If you wish to animate the rotation, see <A HREF="manual_19.html#SEC66">rotate_anim</A>.<BR><BR>

Format: rotate &#60;angle&#62;<BR><BR>

The parameter is a anticlockwise angle in degrees.<BR><BR>

<A NAME="rotate_anim"></A>
<A NAME="SEC66"></A>
<H3> rotate_anim </H3>
<!--docid::SEC66::-->

Sets up an animated rotation effect of this layer. Useful for creating fixed-speed rotation animations (for varying speeds, see <A HREF="manual_19.html#SEC68">wave_xform</A>).<BR><BR>

Format: rotate_anim &#60;revs_per_second&#62;<BR><BR>

The parameter is a number of anticlockwise revolutions per second.<BR><BR>

<A NAME="scale"></A>
<A NAME="SEC67"></A>
<H3> scale </H3>
<!--docid::SEC67::-->

Adjusts the scaling factor applied to this texture layer. Useful for adjusting the size of textures without making changes to geometry. This is a fixed scaling factor, if you wish to animate this see <A HREF="manual_19.html#SEC68">wave_xform</A>.<BR><BR>

Format: scale &#60;x_scale&#62; &#60;y_scale&#62;<BR><BR>

Valid scale values are greater than 0, with a scale factor of 2 making the texture twice as big in that dimension etc.<BR><BR>

<A NAME="wave_xform"></A>
<A NAME="SEC68"></A>
<H3> wave_xform </H3>
<!--docid::SEC68::-->

Sets up a transformation animation based on a wave function. Useful for more advanced texture layer transform effects. You can add multiple instances of this attribute to a single texture layer if you wish.<BR><BR>

Format: wave_xform &#60;xform_type&#62; &#60;wave_type&#62; &#60;base&#62; &#60;frequency&#62; &#60;phase&#62; &#60;amplitude&#62;<BR><BR>

Example: wave_xform scale_x sine 1.0 0.2 0.0 5.0<BR><BR>
<DL COMPACT>
<DT>xform_type
<DD><DL COMPACT>
<DT>scroll_x
<DD>	Animate the x scroll value
<DT>scroll_y
<DD>	Animate the y scroll value
<DT>rotate
<DD>	Animate the rotate value
<DT>scale_x
<DD>	Animate the x scale value
<DT>scale_y
<DD>	Animate the y scale value
</DL>
<DT>wave_type
<DD><DL COMPACT>
<DT>sine
<DD>	A typical sine wave which smoothly loops between min and max values
<DT>triangle
<DD>	An angled wave which increases &#38; decreases at constant speed, changing instantly at the extremes
<DT>square
<DD>	Max for half the wavelength, min for the rest with instant transition between
<DT>sawtooth
<DD>	Gradual steady increase from min to max over the period with an instant return to min at the end.
<DT>inverse_sawtooth
<DD>	Gradual steady decrease from max to min over the period, with an instant return to max at the end.
</DL>
<DT>base
<DD>	The base value, the minimum if amplitude &#62; 0, the maximum if amplitdue &#60; 0
<DT>frequency
<DD>	The number of wave iterations per second, i.e. speed
<DT>phase
<DD>	Offset of the wave start
<DT>amplitude
<DD>	The size of the wave
</DL>
<BR>
The range of the output of the wave will be {base, base+amplitude}. So the example above scales the texture in the x direction between 1 (normal size) and 5 along a sine wave at one cycle every 5 second (0.2 waves per second).<BR><BR>

<A NAME="Declaring Vertex and Fragment Programs"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_18.html#SEC30"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_16.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_20.html#SEC69"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Steve Streeting</I> on <I>, 4 2003</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
