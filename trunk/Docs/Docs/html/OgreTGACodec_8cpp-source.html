<html>
<head>
<title>OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="style.css">
</head>

<body>
<!-- Generated by Doxygen 1.2.16 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>OgreTGACodec.cpp</h1><a href="OgreTGACodec_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment">-----------------------------------------------------------------------------</font>
00003 <font class="comment">This source file is part of OGRE</font>
00004 <font class="comment">(Object-oriented Graphics Rendering Engine)</font>
00005 <font class="comment">For the latest info, see http://www.stevestreeting.com/ogre/</font>
00006 <font class="comment"></font>
00007 <font class="comment">Copyright © 2000-2001 Steven J. Streeting</font>
00008 <font class="comment">Also see acknowledgements in Readme.html</font>
00009 <font class="comment"></font>
00010 <font class="comment">This program is free software; you can redistribute it and/or modify it under</font>
00011 <font class="comment">the terms of the GNU General Public License as published by the Free Software</font>
00012 <font class="comment">Foundation; either version 2 of the License, or (at your option) any later</font>
00013 <font class="comment">version.</font>
00014 <font class="comment"></font>
00015 <font class="comment">This program is distributed in the hope that it will be useful, but WITHOUT</font>
00016 <font class="comment">ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</font>
00017 <font class="comment">FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</font>
00018 <font class="comment"></font>
00019 <font class="comment">You should have received a copy of the GNU General Public License along with</font>
00020 <font class="comment">this program; if not, write to the Free Software Foundation, Inc., 59 Temple</font>
00021 <font class="comment">Place - Suite 330, Boston, MA 02111-1307, USA, or go to</font>
00022 <font class="comment">http://www.gnu.org/copyleft/gpl.html.</font>
00023 <font class="comment">-----------------------------------------------------------------------------</font>
00024 <font class="comment">*/</font>
00025 <font class="preprocessor">#include "<a class="code" href="OgreTGACodec_8h.html">OgreTGACodec.h</a>"</font>
00026 <font class="preprocessor">#include "<a class="code" href="OgreImage_8h.html">OgreImage.h</a>"</font>
00027 <font class="preprocessor">#include "<a class="code" href="OgreException_8h.html">OgreException.h</a>"</font>
00028 
00029 <font class="keyword">namespace </font>Ogre {
00030 
<a name="l00031"></a><a class="code" href="classOgre_1_1TGACodec.html#Ogre_1_1TGACodeca0">00031</a>     <font class="keywordtype">void</font> TGACodec::code( <font class="keyword">const</font> <a class="code" href="classOgre_1_1DataChunk.html">DataChunk</a>&amp; input, <a class="code" href="classOgre_1_1DataChunk.html">DataChunk</a>* output, ... )<font class="keyword"> const</font>
00032 <font class="keyword">    </font>{
00033         <a class="code" href="OgreException_8h.html#a1">OgreGuard</a>( <font class="stringliteral">"TGACodec::code"</font> );
00034         <a class="code" href="OgreException_8h.html#a2">OgreUnguard</a>();
00035     }
00036 
<a name="l00037"></a><a class="code" href="classOgre_1_1TGACodec.html#Ogre_1_1TGACodeca1">00037</a>     <a class="code" href="classOgre_1_1Codec_1_1CodecData.html">Codec::CodecData</a> * TGACodec::decode( <font class="keyword">const</font> <a class="code" href="classOgre_1_1DataChunk.html">DataChunk</a>&amp; input, <a class="code" href="classOgre_1_1DataChunk.html">DataChunk</a>* output, ... )<font class="keyword"> const</font>
00038 <font class="keyword">    </font>{
00039         <a class="code" href="OgreException_8h.html#a1">OgreGuard</a>( <font class="stringliteral">"TGACodec::decode"</font> );
00040         <font class="comment">// Note that this implementation is modified from code</font>
00041         <font class="comment">// Copyright (c) 2000,2001 Bart Sekura</font>
00042 
00043         <font class="comment">// validate hdr</font>
00044         <font class="keyword">const</font> <a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html">TgaHeader</a>* hdr = (<font class="keyword">const</font> <a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html">TgaHeader</a>*) input.<a class="code" href="classOgre_1_1DataChunk.html#Ogre_1_1SDDataChunka6">getPtr</a>();
00045         <font class="keywordflow">if</font>(!(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm2">type</a> == 2 || hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm2">type</a> == 10))
00046         {
00047             <a class="code" href="OgreException_8h.html#a0">Except</a>(Exception::ERR_INTERNAL_ERROR,
00048                 <font class="stringliteral">"Unsupported TGA file type "</font> + hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm2">type</a>,
00049                 <font class="stringliteral">"Image::loadFromTGAinput"</font>);
00050         }
00051 
00052         <font class="keywordtype">unsigned</font> mWidth, mHeight;
00053         <font class="keywordtype">bool</font> mHasAlpha, mIsGreyscale;
00054         byte *mpBuffer;
00055 
00056         mWidth = hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm8">width</a>;
00057         mHeight = hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm9">height</a>;
00058         <font class="keywordflow">if</font> (hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm10">bpp</a> == 32) <font class="comment">// RGBA</font>
00059             mHasAlpha = <font class="keyword">true</font>;
00060         <font class="keywordflow">else</font>
00061             mHasAlpha = <font class="keyword">false</font>;
00062         mIsGreyscale = <font class="keyword">false</font>;
00063 
00064         <font class="keywordtype">int</font> offset = <font class="keyword">sizeof</font>(TgaHeader);
00065         <font class="keywordflow">if</font>(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm0">id_len</a>) {
00066             offset += hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm0">id_len</a>;
00067         }
00068         <font class="keywordflow">if</font>(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm4">cm_len</a>) {
00069             offset += hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm4">cm_len</a>*(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm5">cm_bits</a>&gt;&gt;3);
00070         }
00071 
00072         <font class="keyword">const</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>* data = input.<a class="code" href="classOgre_1_1DataChunk.html#Ogre_1_1SDDataChunka6">getPtr</a>()+offset;
00073         <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> size;
00074         <font class="keywordtype">bool</font> rgb_swap = <font class="keyword">true</font>;
00075 
00076         <font class="comment">// the big ugly switch</font>
00077         <font class="keywordflow">switch</font>(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm2">type</a>) {
00078         <font class="keywordflow">case</font> 2: <font class="comment">// rgb(a)</font>
00079             <font class="keywordflow">switch</font>(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm10">bpp</a>) {
00080         <font class="keywordflow">case</font> 16:
00081             {
00082                 <font class="comment">// upgrade to RGB</font>
00083                 size = mWidth*mHeight*3;
00084                 output-&gt;<a class="code" href="classOgre_1_1DataChunk.html#Ogre_1_1SDDataChunka3">allocate</a>( size );
00085                 mpBuffer = const_cast&lt; byte * &gt;( output-&gt;<a class="code" href="classOgre_1_1DataChunk.html#Ogre_1_1SDDataChunka6">getPtr</a>() );
00086                 <font class="keyword">const</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">short</font>* s = (<font class="keyword">const</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">short</font>*) data;
00087 
00088                 <font class="keywordflow">for</font>( <font class="keywordtype">unsigned</font> i = 0; i &lt; mWidth*mHeight; i++) {
00089                     <font class="keywordtype">unsigned</font> <font class="keywordtype">short</font> tmp = *s++;
00090                     <font class="keywordtype">int</font> r,g,b;
00091                     b = tmp &amp; 0x1f;
00092                     g = (tmp&gt;&gt;5) &amp; 0x1f;
00093                     r = (tmp&gt;&gt;10) &amp; 0x1f;
00094 
00095                     b&lt;&lt;=3,g&lt;&lt;=3,r&lt;&lt;=3;
00096                     mpBuffer[i*3+0]=r;
00097                     mpBuffer[i*3+1]=g;
00098                     mpBuffer[i*3+2]=b;
00099                 }
00100                 rgb_swap = <font class="keyword">false</font>;
00101             }
00102             <font class="keywordflow">break</font>;
00103         <font class="keywordflow">case</font> 24:
00104         <font class="keywordflow">case</font> 32:
00105             {
00106                 size = mWidth*mHeight*(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm10">bpp</a>&gt;&gt;3);
00107                 output-&gt;<a class="code" href="classOgre_1_1DataChunk.html#Ogre_1_1SDDataChunka3">allocate</a>( size );
00108                 mpBuffer = const_cast&lt; byte * &gt;( output-&gt;<a class="code" href="classOgre_1_1DataChunk.html#Ogre_1_1SDDataChunka6">getPtr</a>() );
00109                 memcpy(mpBuffer,data,size);
00110             }
00111             <font class="keywordflow">break</font>;
00112             };
00113             <font class="keywordflow">break</font>;
00114 
00115         <font class="keywordflow">case</font> 10: <font class="comment">// RLE</font>
00116             <font class="keywordflow">switch</font>(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm10">bpp</a>) {
00117         <font class="keywordflow">case</font> 24:
00118         <font class="keywordflow">case</font> 32:
00119             {
00120                 output-&gt;<a class="code" href="classOgre_1_1DataChunk.html#Ogre_1_1SDDataChunka3">allocate</a>( mWidth*mHeight*(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm10">bpp</a>&gt;&gt;3) );
00121                 mpBuffer = const_cast&lt; byte * &gt;( output-&gt;<a class="code" href="classOgre_1_1DataChunk.html#Ogre_1_1SDDataChunka6">getPtr</a>() );                    
00122                 size = mWidth*mHeight;
00123                 <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> i = 0;
00124                 <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>* p = mpBuffer;
00125                 <font class="keyword">const</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>* s = data;
00126                 <font class="keywordtype">int</font> r,g,b,a;
00127 
00128                 <font class="keywordflow">while</font>(i&lt;size) {
00129                     <font class="keywordtype">int</font> rle = (int)*s++&amp;0xff;
00130                     <font class="keywordflow">if</font>(rle&lt;0x80) {
00131                         rle++;
00132                         <font class="keywordflow">while</font>(rle) {
00133                             b = (int)*s++&amp;0xff;
00134                             g = (int)*s++&amp;0xff;
00135                             r = (int)*s++&amp;0xff;
00136                             <font class="keywordflow">if</font>(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm10">bpp</a> == 32) {
00137                                 a = (int)*s++&amp;0xff;
00138                             }
00139 
00140                             *p++ = r;
00141                             *p++ = g;
00142                             *p++ = b;
00143                             <font class="keywordflow">if</font>(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm10">bpp</a> == 32) {
00144                                 *p++ = a;
00145                             }
00146 
00147                             rle--;
00148                             i++;
00149 
00150                             <font class="keywordflow">if</font>(i&gt;size) {
00151                                 <a class="code" href="OgreException_8h.html#a0">Except</a>(Exception::ERR_INTERNAL_ERROR,
00152                                     <font class="stringliteral">"Overrun in TGA RLE read."</font>,
00153                                     <font class="stringliteral">"Image::loadFromTGAinput"</font>);
00154                             }
00155                         }
00156                     }
00157                     <font class="keywordflow">else</font> {
00158                         rle -= 127;
00159 
00160                         b = (int)*s++&amp;0xff;
00161                         g = (int)*s++&amp;0xff;
00162                         r = (int)*s++&amp;0xff;
00163                         <font class="keywordflow">if</font>(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm10">bpp</a> == 32) {
00164                             a = (int)*s++&amp;0xff;
00165                         }
00166 
00167                         <font class="keywordflow">while</font>(rle) {
00168                             *p++ = r;
00169                             *p++ = g;
00170                             *p++ = b;
00171                             <font class="keywordflow">if</font>(hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm10">bpp</a> == 32) {
00172                                 *p++ = a;
00173                             }
00174 
00175                             i++;
00176 
00177                             <font class="keywordflow">if</font>(i&gt;size) {
00178                                 <a class="code" href="OgreException_8h.html#a0">Except</a>(Exception::ERR_INTERNAL_ERROR,
00179                                     <font class="stringliteral">"Overrun in TGA RLE read."</font>,
00180                                     <font class="stringliteral">"Image::loadFromTGAinput"</font>);
00181                             }
00182                             rle--;
00183                         }
00184                     }
00185                 }
00186             }
00187             <font class="keywordflow">break</font>;
00188         <font class="keywordflow">case</font> 8:
00189         <font class="keywordflow">case</font> 16:
00190             <a class="code" href="OgreException_8h.html#a0">Except</a>(Exception::ERR_INTERNAL_ERROR,
00191                 <font class="stringliteral">"Unsupported TGA RLE type."</font>,
00192                 <font class="stringliteral">"Image::loadFromTGAinput"</font>);
00193             }; <font class="comment">// switch</font>
00194             <font class="keywordflow">break</font>;
00195         };
00196 
00197         <font class="comment">// swap bgr to rgb for bpp={24,32}</font>
00198         <font class="keywordtype">int</font> bytes = hdr-&gt;<a class="code" href="structOgre_1_1TGACodec_1_1TgaHeader.html#Ogre_1_1TGACodec_1_1TgaHeaderm10">bpp</a>&gt;&gt;3;
00199 
00200         <font class="keywordflow">if</font>(bytes &gt; 1) {
00201             <font class="keywordflow">for</font>(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> c = 0; c &lt; size; c += bytes) {
00202                 <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> tmp = mpBuffer[c];
00203                 mpBuffer[c] = mpBuffer[c+2];
00204                 mpBuffer[c+2] = tmp;
00205             }
00206         }
00207 
00208         <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>* tmp = <font class="keyword">new</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>[mWidth*bytes];
00209         <font class="keywordflow">for</font>( <font class="keywordtype">unsigned</font> i = 0; i &lt; mHeight/2; i++) {
00210             memcpy(tmp,    mpBuffer + i*mWidth*bytes, mWidth*bytes);
00211             memcpy(mpBuffer + i*mWidth*bytes, mpBuffer + (mHeight-i-1)*mWidth*bytes, mWidth*bytes);
00212             memcpy(mpBuffer + (mHeight-i-1)*mWidth*bytes, tmp, mWidth*bytes);
00213         }
00214         <font class="keyword">delete</font> tmp;
00215 
00216         ImageData * ret_data = <font class="keyword">new</font> ImageData;
00217 
00218         ret_data-&gt;ulHeight = mHeight;
00219         ret_data-&gt;ulWidth = mWidth;
00220         
00221         <a class="code" href="namespaceOgre.html#a292">uchar</a> ucBpp = 0;
00222         <font class="keywordflow">if</font>( mHasAlpha )
00223             ucBpp += 8;
00224         <font class="keywordflow">if</font>( mIsGreyscale )
00225             ucBpp += 8;
00226         <font class="keywordflow">else</font>
00227             ucBpp += 24;
00228 
00229         ret_data-&gt;eFormat = Image::BPP2PF( ucBpp );
00230 
00231         <a class="code" href="OgreException_8h.html#a3">OgreUnguardRet</a>( ret_data );
00232     }
00233 
00234 }
</pre></div><p>
Copyright &copy; 2002 by The OGRE Team<br />
<script type="text/javascript">
<!--//hide script from old browsers
document.write( "Last modified "+ document.lastModified );
//end hiding contents -->
</script>
</p>
</body>
</html>
