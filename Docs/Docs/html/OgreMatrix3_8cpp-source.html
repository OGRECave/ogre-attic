<html>
<head>
<title>OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="style.css">
</head>

<body>
<!-- Generated by Doxygen 1.2.16 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>OgreMatrix3.cpp</h1><a href="OgreMatrix3_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment">-----------------------------------------------------------------------------</font>
00003 <font class="comment">This source file is part of OGRE</font>
00004 <font class="comment">    (Object-oriented Graphics Rendering Engine)</font>
00005 <font class="comment">For the latest info, see http://www.stevestreeting.com/ogre/</font>
00006 <font class="comment"></font>
00007 <font class="comment">Copyright © 2000-2001 Steven J. Streeting</font>
00008 <font class="comment">Also see acknowledgements in Readme.html</font>
00009 <font class="comment"></font>
00010 <font class="comment">This program is free software; you can redistribute it and/or modify it under</font>
00011 <font class="comment">the terms of the GNU General Public License as published by the Free Software</font>
00012 <font class="comment">Foundation; either version 2 of the License, or (at your option) any later</font>
00013 <font class="comment">version.</font>
00014 <font class="comment"></font>
00015 <font class="comment">This program is distributed in the hope that it will be useful, but WITHOUT</font>
00016 <font class="comment">ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</font>
00017 <font class="comment">FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</font>
00018 <font class="comment"></font>
00019 <font class="comment">You should have received a copy of the GNU General Public License along with</font>
00020 <font class="comment">this program; if not, write to the Free Software Foundation, Inc., 59 Temple</font>
00021 <font class="comment">Place - Suite 330, Boston, MA 02111-1307, USA, or go to</font>
00022 <font class="comment">http://www.gnu.org/copyleft/gpl.html.</font>
00023 <font class="comment">-----------------------------------------------------------------------------</font>
00024 <font class="comment">*/</font>
00025 <font class="preprocessor">#include "<a class="code" href="OgreMatrix3_8h.html">OgreMatrix3.h</a>"</font>
00026 
00027 <font class="preprocessor">#include "<a class="code" href="OgreMath_8h.html">OgreMath.h</a>"</font>
00028 
00029 <font class="comment">// Adapted from Matrix math by Wild Magic http://www.magic-software.com</font>
00030 
00031 <font class="keyword">namespace </font>Ogre
00032 {
<a name="l00033"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3p0">00033</a>     <font class="keyword">const</font> <a class="code" href="namespaceOgre.html#a281">Real</a> Matrix3::EPSILON = 1e-06;
00034     <font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> Matrix3::ZERO(0,0,0,0,0,0,0,0,0);
00035     <font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> Matrix3::IDENTITY(1,0,0,0,1,0,0,0,1);
<a name="l00036"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3q0">00036</a>     <font class="keyword">const</font> <a class="code" href="namespaceOgre.html#a281">Real</a> Matrix3::ms_fSvdEpsilon = 1e-04;
<a name="l00037"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3q1">00037</a>     <font class="keyword">const</font> <font class="keywordtype">int</font> Matrix3::ms_iSvdMaxIterations = 32;
00038 
00039     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00040"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a0">00040</a>     Matrix3::Matrix3 ()
00041     {
00042         <font class="comment">// For efficiency reasons, do not initialize matrix.</font>
00043     }
00044     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00045"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a1">00045</a>     Matrix3::Matrix3 (<font class="keyword">const</font> <a class="code" href="namespaceOgre.html#a281">Real</a> aafEntry[3][3])
00046     {
00047         memcpy(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>,aafEntry,9*<font class="keyword">sizeof</font>(<a class="code" href="namespaceOgre.html#a281">Real</a>));
00048     }
00049     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00050"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a2">00050</a>     Matrix3::Matrix3 (<font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; rkMatrix)
00051     {
00052         memcpy(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>,rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>,9*<font class="keyword">sizeof</font>(<a class="code" href="namespaceOgre.html#a281">Real</a>));
00053     }
00054     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00055"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a3">00055</a>     Matrix3::Matrix3 (<a class="code" href="namespaceOgre.html#a281">Real</a> fEntry00, <a class="code" href="namespaceOgre.html#a281">Real</a> fEntry01, <a class="code" href="namespaceOgre.html#a281">Real</a> fEntry02,
00056         <a class="code" href="namespaceOgre.html#a281">Real</a> fEntry10, <a class="code" href="namespaceOgre.html#a281">Real</a> fEntry11, <a class="code" href="namespaceOgre.html#a281">Real</a> fEntry12, <a class="code" href="namespaceOgre.html#a281">Real</a> fEntry20,
00057         <a class="code" href="namespaceOgre.html#a281">Real</a> fEntry21, <a class="code" href="namespaceOgre.html#a281">Real</a> fEntry22)
00058     {
00059         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] = fEntry00;
00060         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1] = fEntry01;
00061         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] = fEntry02;
00062         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0] = fEntry10;
00063         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] = fEntry11;
00064         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] = fEntry12;
00065         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0] = fEntry20;
00066         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1] = fEntry21;
00067         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] = fEntry22;
00068     }
00069     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00070"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a4">00070</a>     <a class="code" href="namespaceOgre.html#a281">Real</a>* Matrix3::operator[] (<font class="keywordtype">int</font> iRow)<font class="keyword"> const</font>
00071 <font class="keyword">    </font>{
00072         <font class="keywordflow">return</font> (<a class="code" href="namespaceOgre.html#a281">Real</a>*)<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow];
00073     }
00074     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00075"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a5">00075</a>     Matrix3::operator Real* ()
00076     {
00077         <font class="keywordflow">return</font> (<a class="code" href="namespaceOgre.html#a281">Real</a>*)<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0];
00078     }
00079     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00080"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a6">00080</a>     <a class="code" href="classOgre_1_1Vector3.html">Vector3</a> Matrix3::GetColumn (<font class="keywordtype">int</font> iCol)<font class="keyword"> const</font>
00081 <font class="keyword">    </font>{
00082         assert( 0 &lt;= iCol &amp;&amp; iCol &lt; 3 );
00083         <font class="keywordflow">return</font> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][iCol],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][iCol],
00084             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][iCol]);
00085     }
00086     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00087"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a7">00087</a>     <font class="keywordtype">void</font> Matrix3::SetColumn(<font class="keywordtype">int</font> iCol, <font class="keyword">const</font> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; vec)
00088     {
00089         assert( 0 &lt;= iCol &amp;&amp; iCol &lt; 3 );
00090         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][iCol] = vec.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a>;
00091         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][iCol] = vec.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a>;
00092         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][iCol] = vec.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a>;
00093 
00094     }
00095     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00096"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a8">00096</a>     <font class="keywordtype">void</font> Matrix3::FromAxes(<font class="keyword">const</font> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; xAxis, <font class="keyword">const</font> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; yAxis, <font class="keyword">const</font> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; zAxis)
00097     {
00098         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a7">SetColumn</a>(0,xAxis);
00099         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a7">SetColumn</a>(1,yAxis);
00100         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a7">SetColumn</a>(2,zAxis);
00101 
00102     }
00103 
00104     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00105"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a9">00105</a>     <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; Matrix3::operator= (<font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; rkMatrix)
00106     {
00107         memcpy(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>,rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>,9*<font class="keyword">sizeof</font>(<a class="code" href="namespaceOgre.html#a281">Real</a>));
00108         <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00109     }
00110     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00111"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a10">00111</a>     <font class="keywordtype">bool</font> Matrix3::operator== (<font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; rkMatrix)<font class="keyword"> const</font>
00112 <font class="keyword">    </font>{
00113         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00114         {
00115             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iCol = 0; iCol &lt; 3; iCol++)
00116             {
00117                 <font class="keywordflow">if</font> ( <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol] != rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol] )
00118                     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00119             }
00120         }
00121 
00122         <font class="keywordflow">return</font> <font class="keyword">true</font>;
00123     }
00124     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00125"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a11">00125</a>     <font class="keywordtype">bool</font> Matrix3::operator!= (<font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; rkMatrix)<font class="keyword"> const</font>
00126 <font class="keyword">    </font>{
00127         <font class="keywordflow">return</font> !<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a10">operator==</a>(rkMatrix);
00128     }
00129     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00130"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a12">00130</a>     <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> Matrix3::operator+ (<font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; rkMatrix)<font class="keyword"> const</font>
00131 <font class="keyword">    </font>{
00132         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kSum;
00133         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00134         {
00135             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iCol = 0; iCol &lt; 3; iCol++)
00136             {
00137                 kSum.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol] +
00138                     rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol];
00139             }
00140         }
00141         <font class="keywordflow">return</font> kSum;
00142     }
00143     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00144"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a13">00144</a>     <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> Matrix3::operator- (<font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; rkMatrix)<font class="keyword"> const</font>
00145 <font class="keyword">    </font>{
00146         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kDiff;
00147         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00148         {
00149             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iCol = 0; iCol &lt; 3; iCol++)
00150             {
00151                 kDiff.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol] -
00152                     rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol];
00153             }
00154         }
00155         <font class="keywordflow">return</font> kDiff;
00156     }
00157     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00158"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a14">00158</a>     <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> Matrix3::operator* (<font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; rkMatrix)<font class="keyword"> const</font>
00159 <font class="keyword">    </font>{
00160         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kProd;
00161         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00162         {
00163             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iCol = 0; iCol &lt; 3; iCol++)
00164             {
00165                 kProd.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol] =
00166                     <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][0]*rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][iCol] +
00167                     <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][1]*rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][iCol] +
00168                     <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][2]*rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][iCol];
00169             }
00170         }
00171         <font class="keywordflow">return</font> kProd;
00172     }
00173     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00174"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a16">00174</a>     <a class="code" href="classOgre_1_1Vector3.html">Vector3</a> Matrix3::operator* (<font class="keyword">const</font> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; rkPoint)<font class="keyword"> const</font>
00175 <font class="keyword">    </font>{
00176         <a class="code" href="classOgre_1_1Vector3.html">Vector3</a> kProd;
00177         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00178         {
00179             kProd[iRow] =
00180                 <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][0]*rkPoint[0] +
00181                 <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][1]*rkPoint[1] +
00182                 <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][2]*rkPoint[2];
00183         }
00184         <font class="keywordflow">return</font> kProd;
00185     }
00186     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00187"></a><a class="code" href="namespaceOgre.html#a385">00187</a>     <a class="code" href="classOgre_1_1Vector3.html">Vector3</a> <a class="code" href="namespaceOgre.html#a385">operator* </a>(<font class="keyword">const</font> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; rkPoint, <font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; rkMatrix)
00188     {
00189         <a class="code" href="classOgre_1_1Vector3.html">Vector3</a> kProd;
00190         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00191         {
00192             kProd[iRow] =
00193                 rkPoint[0]*rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][iRow] +
00194                 rkPoint[1]*rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][iRow] +
00195                 rkPoint[2]*rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][iRow];
00196         }
00197         <font class="keywordflow">return</font> kProd;
00198     }
00199     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00200"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a15">00200</a>     <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> Matrix3::operator- ()<font class="keyword"> const</font>
00201 <font class="keyword">    </font>{
00202         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kNeg;
00203         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00204         {
00205             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iCol = 0; iCol &lt; 3; iCol++)
00206                 kNeg[iRow][iCol] = -<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol];
00207         }
00208         <font class="keywordflow">return</font> kNeg;
00209     }
00210     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00211"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a17">00211</a>     <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> Matrix3::operator* (<a class="code" href="namespaceOgre.html#a281">Real</a> fScalar)<font class="keyword"> const</font>
00212 <font class="keyword">    </font>{
00213         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kProd;
00214         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00215         {
00216             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iCol = 0; iCol &lt; 3; iCol++)
00217                 kProd[iRow][iCol] = fScalar*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol];
00218         }
00219         <font class="keywordflow">return</font> kProd;
00220     }
00221     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00222"></a><a class="code" href="namespaceOgre.html#a386">00222</a>     <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> <a class="code" href="namespaceOgre.html#a385">operator* </a>(<a class="code" href="namespaceOgre.html#a281">Real</a> fScalar, <font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; rkMatrix)
00223     {
00224         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kProd;
00225         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00226         {
00227             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iCol = 0; iCol &lt; 3; iCol++)
00228                 kProd[iRow][iCol] = fScalar*rkMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol];
00229         }
00230         <font class="keywordflow">return</font> kProd;
00231     }
00232     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00233"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a18">00233</a>     <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> Matrix3::Transpose ()<font class="keyword"> const</font>
00234 <font class="keyword">    </font>{
00235         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kTranspose;
00236         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00237         {
00238             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iCol = 0; iCol &lt; 3; iCol++)
00239                 kTranspose[iRow][iCol] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iCol][iRow];
00240         }
00241         <font class="keywordflow">return</font> kTranspose;
00242     }
00243     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00244"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a19">00244</a>     <font class="keywordtype">bool</font> Matrix3::Inverse (<a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; rkInverse, <a class="code" href="namespaceOgre.html#a281">Real</a> fTolerance)<font class="keyword"> const</font>
00245 <font class="keyword">    </font>{
00246         <font class="comment">// Invert a 3x3 using cofactors.  This is about 8 times faster than</font>
00247         <font class="comment">// the Numerical Recipes code which uses Gaussian elimination.</font>
00248 
00249         rkInverse[0][0] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] -
00250             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1];
00251         rkInverse[0][1] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1] -
00252             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
00253         rkInverse[0][2] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] -
00254             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1];
00255         rkInverse[1][0] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0] -
00256             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
00257         rkInverse[1][1] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] -
00258             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0];
00259         rkInverse[1][2] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0] -
00260             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2];
00261         rkInverse[2][0] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1] -
00262             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0];
00263         rkInverse[2][1] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0] -
00264             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1];
00265         rkInverse[2][2] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] -
00266             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0];
00267 
00268         <a class="code" href="namespaceOgre.html#a281">Real</a> fDet =
00269             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]*rkInverse[0][0] +
00270             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1]*rkInverse[1][0]+
00271             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]*rkInverse[2][0];
00272 
00273         <font class="keywordflow">if</font> ( Math::getSingleton().Abs(fDet) &lt;= fTolerance )
00274             <font class="keywordflow">return</font> <font class="keyword">false</font>;
00275 
00276         <a class="code" href="namespaceOgre.html#a281">Real</a> fInvDet = 1.0/fDet;
00277         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00278         {
00279             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iCol = 0; iCol &lt; 3; iCol++)
00280                 rkInverse[iRow][iCol] *= fInvDet;
00281         }
00282 
00283         <font class="keywordflow">return</font> <font class="keyword">true</font>;
00284     }
00285     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00286"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a20">00286</a>     <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> Matrix3::Inverse (<a class="code" href="namespaceOgre.html#a281">Real</a> fTolerance)<font class="keyword"> const</font>
00287 <font class="keyword">    </font>{
00288         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kInverse = Matrix3::ZERO;
00289         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a19">Inverse</a>(kInverse,fTolerance);
00290         <font class="keywordflow">return</font> kInverse;
00291     }
00292     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00293"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a21">00293</a>     <a class="code" href="namespaceOgre.html#a281">Real</a> Matrix3::Determinant ()<font class="keyword"> const</font>
00294 <font class="keyword">    </font>{
00295         <a class="code" href="namespaceOgre.html#a281">Real</a> fCofactor00 = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] -
00296             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1];
00297         <a class="code" href="namespaceOgre.html#a281">Real</a> fCofactor10 = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0] -
00298             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
00299         <a class="code" href="namespaceOgre.html#a281">Real</a> fCofactor20 = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1] -
00300             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0];
00301 
00302         <a class="code" href="namespaceOgre.html#a281">Real</a> fDet =
00303             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]*fCofactor00 +
00304             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1]*fCofactor10 +
00305             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]*fCofactor20;
00306 
00307         <font class="keywordflow">return</font> fDet;
00308     }
00309     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00310"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3e0">00310</a>     <font class="keywordtype">void</font> Matrix3::Bidiagonalize (<a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; kA, <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; kL,
00311         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; kR)
00312     {
00313         <a class="code" href="namespaceOgre.html#a281">Real</a> afV[3], afW[3];
00314         <a class="code" href="namespaceOgre.html#a281">Real</a> fLength, fSign, fT1, fInvT1, fT2;
00315         <font class="keywordtype">bool</font> bIdentity;
00316 
00317         <font class="comment">// map first column to (*,0,0)</font>
00318         fLength = Math::getSingleton().Sqrt(kA[0][0]*kA[0][0] + kA[1][0]*kA[1][0] +
00319             kA[2][0]*kA[2][0]);
00320         <font class="keywordflow">if</font> ( fLength &gt; 0.0 )
00321         {
00322             fSign = (kA[0][0] &gt; 0.0 ? 1.0 : -1.0);
00323             fT1 = kA[0][0] + fSign*fLength;
00324             fInvT1 = 1.0/fT1;
00325             afV[1] = kA[1][0]*fInvT1;
00326             afV[2] = kA[2][0]*fInvT1;
00327 
00328             fT2 = -2.0/(1.0+afV[1]*afV[1]+afV[2]*afV[2]);
00329             afW[0] = fT2*(kA[0][0]+kA[1][0]*afV[1]+kA[2][0]*afV[2]);
00330             afW[1] = fT2*(kA[0][1]+kA[1][1]*afV[1]+kA[2][1]*afV[2]);
00331             afW[2] = fT2*(kA[0][2]+kA[1][2]*afV[1]+kA[2][2]*afV[2]);
00332             kA[0][0] += afW[0];
00333             kA[0][1] += afW[1];
00334             kA[0][2] += afW[2];
00335             kA[1][1] += afV[1]*afW[1];
00336             kA[1][2] += afV[1]*afW[2];
00337             kA[2][1] += afV[2]*afW[1];
00338             kA[2][2] += afV[2]*afW[2];
00339 
00340             kL[0][0] = 1.0+fT2;
00341             kL[0][1] = kL[1][0] = fT2*afV[1];
00342             kL[0][2] = kL[2][0] = fT2*afV[2];
00343             kL[1][1] = 1.0+fT2*afV[1]*afV[1];
00344             kL[1][2] = kL[2][1] = fT2*afV[1]*afV[2];
00345             kL[2][2] = 1.0+fT2*afV[2]*afV[2];
00346             bIdentity = <font class="keyword">false</font>;
00347         }
00348         <font class="keywordflow">else</font>
00349         {
00350             kL = Matrix3::IDENTITY;
00351             bIdentity = <font class="keyword">true</font>;
00352         }
00353 
00354         <font class="comment">// map first row to (*,*,0)</font>
00355         fLength = Math::getSingleton().Sqrt(kA[0][1]*kA[0][1]+kA[0][2]*kA[0][2]);
00356         <font class="keywordflow">if</font> ( fLength &gt; 0.0 )
00357         {
00358             fSign = (kA[0][1] &gt; 0.0 ? 1.0 : -1.0);
00359             fT1 = kA[0][1] + fSign*fLength;
00360             afV[2] = kA[0][2]/fT1;
00361 
00362             fT2 = -2.0/(1.0+afV[2]*afV[2]);
00363             afW[0] = fT2*(kA[0][1]+kA[0][2]*afV[2]);
00364             afW[1] = fT2*(kA[1][1]+kA[1][2]*afV[2]);
00365             afW[2] = fT2*(kA[2][1]+kA[2][2]*afV[2]);
00366             kA[0][1] += afW[0];
00367             kA[1][1] += afW[1];
00368             kA[1][2] += afW[1]*afV[2];
00369             kA[2][1] += afW[2];
00370             kA[2][2] += afW[2]*afV[2];
00371 
00372             kR[0][0] = 1.0;
00373             kR[0][1] = kR[1][0] = 0.0;
00374             kR[0][2] = kR[2][0] = 0.0;
00375             kR[1][1] = 1.0+fT2;
00376             kR[1][2] = kR[2][1] = fT2*afV[2];
00377             kR[2][2] = 1.0+fT2*afV[2]*afV[2];
00378         }
00379         <font class="keywordflow">else</font>
00380         {
00381             kR = Matrix3::IDENTITY;
00382         }
00383 
00384         <font class="comment">// map second column to (*,*,0)</font>
00385         fLength = Math::getSingleton().Sqrt(kA[1][1]*kA[1][1]+kA[2][1]*kA[2][1]);
00386         <font class="keywordflow">if</font> ( fLength &gt; 0.0 )
00387         {
00388             fSign = (kA[1][1] &gt; 0.0 ? 1.0 : -1.0);
00389             fT1 = kA[1][1] + fSign*fLength;
00390             afV[2] = kA[2][1]/fT1;
00391 
00392             fT2 = -2.0/(1.0+afV[2]*afV[2]);
00393             afW[1] = fT2*(kA[1][1]+kA[2][1]*afV[2]);
00394             afW[2] = fT2*(kA[1][2]+kA[2][2]*afV[2]);
00395             kA[1][1] += afW[1];
00396             kA[1][2] += afW[2];
00397             kA[2][2] += afV[2]*afW[2];
00398 
00399             <a class="code" href="namespaceOgre.html#a281">Real</a> fA = 1.0+fT2;
00400             <a class="code" href="namespaceOgre.html#a281">Real</a> fB = fT2*afV[2];
00401             <a class="code" href="namespaceOgre.html#a281">Real</a> fC = 1.0+fB*afV[2];
00402 
00403             <font class="keywordflow">if</font> ( bIdentity )
00404             {
00405                 kL[0][0] = 1.0;
00406                 kL[0][1] = kL[1][0] = 0.0;
00407                 kL[0][2] = kL[2][0] = 0.0;
00408                 kL[1][1] = fA;
00409                 kL[1][2] = kL[2][1] = fB;
00410                 kL[2][2] = fC;
00411             }
00412             <font class="keywordflow">else</font>
00413             {
00414                 <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00415                 {
00416                     <a class="code" href="namespaceOgre.html#a281">Real</a> fTmp0 = kL[iRow][1];
00417                     <a class="code" href="namespaceOgre.html#a281">Real</a> fTmp1 = kL[iRow][2];
00418                     kL[iRow][1] = fA*fTmp0+fB*fTmp1;
00419                     kL[iRow][2] = fB*fTmp0+fC*fTmp1;
00420                 }
00421             }
00422         }
00423     }
00424     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00425"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3e1">00425</a>     <font class="keywordtype">void</font> Matrix3::GolubKahanStep (<a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; kA, <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; kL,
00426         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; kR)
00427     {
00428         <a class="code" href="namespaceOgre.html#a281">Real</a> fT11 = kA[0][1]*kA[0][1]+kA[1][1]*kA[1][1];
00429         <a class="code" href="namespaceOgre.html#a281">Real</a> fT22 = kA[1][2]*kA[1][2]+kA[2][2]*kA[2][2];
00430         <a class="code" href="namespaceOgre.html#a281">Real</a> fT12 = kA[1][1]*kA[1][2];
00431         <a class="code" href="namespaceOgre.html#a281">Real</a> fTrace = fT11+fT22;
00432         <a class="code" href="namespaceOgre.html#a281">Real</a> fDiff = fT11-fT22;
00433         <a class="code" href="namespaceOgre.html#a281">Real</a> fDiscr = Math::getSingleton().Sqrt(fDiff*fDiff+4.0*fT12*fT12);
00434         <a class="code" href="namespaceOgre.html#a281">Real</a> fRoot1 = 0.5*(fTrace+fDiscr);
00435         <a class="code" href="namespaceOgre.html#a281">Real</a> fRoot2 = 0.5*(fTrace-fDiscr);
00436 
00437         <font class="comment">// adjust right</font>
00438         <a class="code" href="namespaceOgre.html#a281">Real</a> fY = kA[0][0] - (Math::getSingleton().Abs(fRoot1-fT22) &lt;=
00439             Math::getSingleton().Abs(fRoot2-fT22) ? fRoot1 : fRoot2);
00440         <a class="code" href="namespaceOgre.html#a281">Real</a> fZ = kA[0][1];
00441         <a class="code" href="namespaceOgre.html#a281">Real</a> fInvLength = 1.0/Math::getSingleton().Sqrt(fY*fY+fZ*fZ);
00442         <a class="code" href="namespaceOgre.html#a281">Real</a> fSin = fZ*fInvLength;
00443         <a class="code" href="namespaceOgre.html#a281">Real</a> fCos = -fY*fInvLength;
00444 
00445         <a class="code" href="namespaceOgre.html#a281">Real</a> fTmp0 = kA[0][0];
00446         <a class="code" href="namespaceOgre.html#a281">Real</a> fTmp1 = kA[0][1];
00447         kA[0][0] = fCos*fTmp0-fSin*fTmp1;
00448         kA[0][1] = fSin*fTmp0+fCos*fTmp1;
00449         kA[1][0] = -fSin*kA[1][1];
00450         kA[1][1] *= fCos;
00451 
00452         <font class="keywordtype">int</font> iRow;
00453         <font class="keywordflow">for</font> (iRow = 0; iRow &lt; 3; iRow++)
00454         {
00455             fTmp0 = kR[0][iRow];
00456             fTmp1 = kR[1][iRow];
00457             kR[0][iRow] = fCos*fTmp0-fSin*fTmp1;
00458             kR[1][iRow] = fSin*fTmp0+fCos*fTmp1;
00459         }
00460 
00461         <font class="comment">// adjust left</font>
00462         fY = kA[0][0];
00463         fZ = kA[1][0];
00464         fInvLength = 1.0/Math::getSingleton().Sqrt(fY*fY+fZ*fZ);
00465         fSin = fZ*fInvLength;
00466         fCos = -fY*fInvLength;
00467 
00468         kA[0][0] = fCos*kA[0][0]-fSin*kA[1][0];
00469         fTmp0 = kA[0][1];
00470         fTmp1 = kA[1][1];
00471         kA[0][1] = fCos*fTmp0-fSin*fTmp1;
00472         kA[1][1] = fSin*fTmp0+fCos*fTmp1;
00473         kA[0][2] = -fSin*kA[1][2];
00474         kA[1][2] *= fCos;
00475 
00476         <font class="keywordtype">int</font> iCol;
00477         <font class="keywordflow">for</font> (iCol = 0; iCol &lt; 3; iCol++)
00478         {
00479             fTmp0 = kL[iCol][0];
00480             fTmp1 = kL[iCol][1];
00481             kL[iCol][0] = fCos*fTmp0-fSin*fTmp1;
00482             kL[iCol][1] = fSin*fTmp0+fCos*fTmp1;
00483         }
00484 
00485         <font class="comment">// adjust right</font>
00486         fY = kA[0][1];
00487         fZ = kA[0][2];
00488         fInvLength = 1.0/Math::getSingleton().Sqrt(fY*fY+fZ*fZ);
00489         fSin = fZ*fInvLength;
00490         fCos = -fY*fInvLength;
00491 
00492         kA[0][1] = fCos*kA[0][1]-fSin*kA[0][2];
00493         fTmp0 = kA[1][1];
00494         fTmp1 = kA[1][2];
00495         kA[1][1] = fCos*fTmp0-fSin*fTmp1;
00496         kA[1][2] = fSin*fTmp0+fCos*fTmp1;
00497         kA[2][1] = -fSin*kA[2][2];
00498         kA[2][2] *= fCos;
00499 
00500         <font class="keywordflow">for</font> (iRow = 0; iRow &lt; 3; iRow++)
00501         {
00502             fTmp0 = kR[1][iRow];
00503             fTmp1 = kR[2][iRow];
00504             kR[1][iRow] = fCos*fTmp0-fSin*fTmp1;
00505             kR[2][iRow] = fSin*fTmp0+fCos*fTmp1;
00506         }
00507 
00508         <font class="comment">// adjust left</font>
00509         fY = kA[1][1];
00510         fZ = kA[2][1];
00511         fInvLength = 1.0/Math::getSingleton().Sqrt(fY*fY+fZ*fZ);
00512         fSin = fZ*fInvLength;
00513         fCos = -fY*fInvLength;
00514 
00515         kA[1][1] = fCos*kA[1][1]-fSin*kA[2][1];
00516         fTmp0 = kA[1][2];
00517         fTmp1 = kA[2][2];
00518         kA[1][2] = fCos*fTmp0-fSin*fTmp1;
00519         kA[2][2] = fSin*fTmp0+fCos*fTmp1;
00520 
00521         <font class="keywordflow">for</font> (iCol = 0; iCol &lt; 3; iCol++)
00522         {
00523             fTmp0 = kL[iCol][1];
00524             fTmp1 = kL[iCol][2];
00525             kL[iCol][1] = fCos*fTmp0-fSin*fTmp1;
00526             kL[iCol][2] = fSin*fTmp0+fCos*fTmp1;
00527         }
00528     }
00529     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00530"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a22">00530</a>     <font class="keywordtype">void</font> Matrix3::SingularValueDecomposition (<a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; kL, <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; kS,
00531         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; kR)<font class="keyword"> const</font>
00532 <font class="keyword">    </font>{
00533         <font class="comment">// temas: currently unused</font>
00534         <font class="comment">//const int iMax = 16;</font>
00535         <font class="keywordtype">int</font> iRow, iCol;
00536 
00537         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kA = *<font class="keyword">this</font>;
00538         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3e0">Bidiagonalize</a>(kA,kL,kR);
00539 
00540         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3q1">ms_iSvdMaxIterations</a>; i++)
00541         {
00542             <a class="code" href="namespaceOgre.html#a281">Real</a> fTmp, fTmp0, fTmp1;
00543             <a class="code" href="namespaceOgre.html#a281">Real</a> fSin0, fCos0, fTan0;
00544             <a class="code" href="namespaceOgre.html#a281">Real</a> fSin1, fCos1, fTan1;
00545 
00546             <font class="keywordtype">bool</font> bTest1 = (Math::getSingleton().Abs(kA[0][1]) &lt;=
00547                 <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3q0">ms_fSvdEpsilon</a>*(Math::getSingleton().Abs(kA[0][0])+Math::getSingleton().Abs(kA[1][1])));
00548             <font class="keywordtype">bool</font> bTest2 = (Math::getSingleton().Abs(kA[1][2]) &lt;=
00549                 <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3q0">ms_fSvdEpsilon</a>*(Math::getSingleton().Abs(kA[1][1])+Math::getSingleton().Abs(kA[2][2])));
00550             <font class="keywordflow">if</font> ( bTest1 )
00551             {
00552                 <font class="keywordflow">if</font> ( bTest2 )
00553                 {
00554                     kS[0] = kA[0][0];
00555                     kS[1] = kA[1][1];
00556                     kS[2] = kA[2][2];
00557                     <font class="keywordflow">break</font>;
00558                 }
00559                 <font class="keywordflow">else</font>
00560                 {
00561                     <font class="comment">// 2x2 closed form factorization</font>
00562                     fTmp = (kA[1][1]*kA[1][1] - kA[2][2]*kA[2][2] +
00563                         kA[1][2]*kA[1][2])/(kA[1][2]*kA[2][2]);
00564                     fTan0 = 0.5*(fTmp+Math::getSingleton().Sqrt(fTmp*fTmp + 4.0));
00565                     fCos0 = 1.0/Math::getSingleton().Sqrt(1.0+fTan0*fTan0);
00566                     fSin0 = fTan0*fCos0;
00567 
00568                     <font class="keywordflow">for</font> (iCol = 0; iCol &lt; 3; iCol++)
00569                     {
00570                         fTmp0 = kL[iCol][1];
00571                         fTmp1 = kL[iCol][2];
00572                         kL[iCol][1] = fCos0*fTmp0-fSin0*fTmp1;
00573                         kL[iCol][2] = fSin0*fTmp0+fCos0*fTmp1;
00574                     }
00575 
00576                     fTan1 = (kA[1][2]-kA[2][2]*fTan0)/kA[1][1];
00577                     fCos1 = 1.0/Math::getSingleton().Sqrt(1.0+fTan1*fTan1);
00578                     fSin1 = -fTan1*fCos1;
00579 
00580                     <font class="keywordflow">for</font> (iRow = 0; iRow &lt; 3; iRow++)
00581                     {
00582                         fTmp0 = kR[1][iRow];
00583                         fTmp1 = kR[2][iRow];
00584                         kR[1][iRow] = fCos1*fTmp0-fSin1*fTmp1;
00585                         kR[2][iRow] = fSin1*fTmp0+fCos1*fTmp1;
00586                     }
00587 
00588                     kS[0] = kA[0][0];
00589                     kS[1] = fCos0*fCos1*kA[1][1] -
00590                         fSin1*(fCos0*kA[1][2]-fSin0*kA[2][2]);
00591                     kS[2] = fSin0*fSin1*kA[1][1] +
00592                         fCos1*(fSin0*kA[1][2]+fCos0*kA[2][2]);
00593                     <font class="keywordflow">break</font>;
00594                 }
00595             }
00596             <font class="keywordflow">else</font>
00597             {
00598                 <font class="keywordflow">if</font> ( bTest2 )
00599                 {
00600                     <font class="comment">// 2x2 closed form factorization</font>
00601                     fTmp = (kA[0][0]*kA[0][0] + kA[1][1]*kA[1][1] -
00602                         kA[0][1]*kA[0][1])/(kA[0][1]*kA[1][1]);
00603                     fTan0 = 0.5*(-fTmp+Math::getSingleton().Sqrt(fTmp*fTmp + 4.0));
00604                     fCos0 = 1.0/Math::getSingleton().Sqrt(1.0+fTan0*fTan0);
00605                     fSin0 = fTan0*fCos0;
00606 
00607                     <font class="keywordflow">for</font> (iCol = 0; iCol &lt; 3; iCol++)
00608                     {
00609                         fTmp0 = kL[iCol][0];
00610                         fTmp1 = kL[iCol][1];
00611                         kL[iCol][0] = fCos0*fTmp0-fSin0*fTmp1;
00612                         kL[iCol][1] = fSin0*fTmp0+fCos0*fTmp1;
00613                     }
00614 
00615                     fTan1 = (kA[0][1]-kA[1][1]*fTan0)/kA[0][0];
00616                     fCos1 = 1.0/Math::getSingleton().Sqrt(1.0+fTan1*fTan1);
00617                     fSin1 = -fTan1*fCos1;
00618 
00619                     <font class="keywordflow">for</font> (iRow = 0; iRow &lt; 3; iRow++)
00620                     {
00621                         fTmp0 = kR[0][iRow];
00622                         fTmp1 = kR[1][iRow];
00623                         kR[0][iRow] = fCos1*fTmp0-fSin1*fTmp1;
00624                         kR[1][iRow] = fSin1*fTmp0+fCos1*fTmp1;
00625                     }
00626 
00627                     kS[0] = fCos0*fCos1*kA[0][0] -
00628                         fSin1*(fCos0*kA[0][1]-fSin0*kA[1][1]);
00629                     kS[1] = fSin0*fSin1*kA[0][0] +
00630                         fCos1*(fSin0*kA[0][1]+fCos0*kA[1][1]);
00631                     kS[2] = kA[2][2];
00632                     <font class="keywordflow">break</font>;
00633                 }
00634                 <font class="keywordflow">else</font>
00635                 {
00636                     <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3e1">GolubKahanStep</a>(kA,kL,kR);
00637                 }
00638             }
00639         }
00640 
00641         <font class="comment">// positize diagonal</font>
00642         <font class="keywordflow">for</font> (iRow = 0; iRow &lt; 3; iRow++)
00643         {
00644             <font class="keywordflow">if</font> ( kS[iRow] &lt; 0.0 )
00645             {
00646                 kS[iRow] = -kS[iRow];
00647                 <font class="keywordflow">for</font> (iCol = 0; iCol &lt; 3; iCol++)
00648                     kR[iRow][iCol] = -kR[iRow][iCol];
00649             }
00650         }
00651     }
00652     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00653"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a23">00653</a>     <font class="keywordtype">void</font> Matrix3::SingularValueComposition (<font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; kL,
00654         <font class="keyword">const</font> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; kS, <font class="keyword">const</font> <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; kR)
00655     {
00656         <font class="keywordtype">int</font> iRow, iCol;
00657         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kTmp;
00658 
00659         <font class="comment">// product S*R</font>
00660         <font class="keywordflow">for</font> (iRow = 0; iRow &lt; 3; iRow++)
00661         {
00662             <font class="keywordflow">for</font> (iCol = 0; iCol &lt; 3; iCol++)
00663                 kTmp[iRow][iCol] = kS[iRow]*kR[iRow][iCol];
00664         }
00665 
00666         <font class="comment">// product L*S*R</font>
00667         <font class="keywordflow">for</font> (iRow = 0; iRow &lt; 3; iRow++)
00668         {
00669             <font class="keywordflow">for</font> (iCol = 0; iCol &lt; 3; iCol++)
00670             {
00671                 <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol] = 0.0;
00672                 <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iMid = 0; iMid &lt; 3; iMid++)
00673                     <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][iCol] += kL[iRow][iMid]*kTmp[iMid][iCol];
00674             }
00675         }
00676     }
00677     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00678"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a24">00678</a>     <font class="keywordtype">void</font> Matrix3::Orthonormalize ()
00679     {
00680         <font class="comment">// Algorithm uses Gram-Schmidt orthogonalization.  If 'this' matrix is</font>
00681         <font class="comment">// M = [m0|m1|m2], then orthonormal output matrix is Q = [q0|q1|q2],</font>
00682         <font class="comment">//</font>
00683         <font class="comment">//   q0 = m0/|m0|</font>
00684         <font class="comment">//   q1 = (m1-(q0*m1)q0)/|m1-(q0*m1)q0|</font>
00685         <font class="comment">//   q2 = (m2-(q0*m2)q0-(q1*m2)q1)/|m2-(q0*m2)q0-(q1*m2)q1|</font>
00686         <font class="comment">//</font>
00687         <font class="comment">// where |V| indicates length of vector V and A*B indicates dot</font>
00688         <font class="comment">// product of vectors A and B.</font>
00689 
00690         <font class="comment">// compute q0</font>
00691         <a class="code" href="namespaceOgre.html#a281">Real</a> fInvLength = 1.0/Math::getSingleton().Sqrt(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]
00692             + <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0] +
00693             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0]);
00694 
00695         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] *= fInvLength;
00696         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0] *= fInvLength;
00697         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0] *= fInvLength;
00698 
00699         <font class="comment">// compute q1</font>
00700         <a class="code" href="namespaceOgre.html#a281">Real</a> fDot0 =
00701             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1] +
00702             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] +
00703             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1];
00704 
00705         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1] -= fDot0*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0];
00706         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] -= fDot0*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0];
00707         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1] -= fDot0*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0];
00708 
00709         fInvLength = 1.0/Math::getSingleton().Sqrt(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1] +
00710             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] +
00711             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1]);
00712 
00713         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1] *= fInvLength;
00714         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] *= fInvLength;
00715         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1] *= fInvLength;
00716 
00717         <font class="comment">// compute q2</font>
00718         <a class="code" href="namespaceOgre.html#a281">Real</a> fDot1 =
00719             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] +
00720             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] +
00721             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
00722 
00723         fDot0 =
00724             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] +
00725             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] +
00726             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
00727 
00728         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] -= fDot0*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] + fDot1*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1];
00729         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] -= fDot0*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0] + fDot1*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1];
00730         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] -= fDot0*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0] + fDot1*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1];
00731 
00732         fInvLength = 1.0/Math::getSingleton().Sqrt(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] +
00733             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] +
00734             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2]);
00735 
00736         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] *= fInvLength;
00737         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] *= fInvLength;
00738         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] *= fInvLength;
00739     }
00740     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00741"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a25">00741</a>     <font class="keywordtype">void</font> Matrix3::QDUDecomposition (<a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; kQ,
00742         <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; kD, <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; kU)<font class="keyword"> const</font>
00743 <font class="keyword">    </font>{
00744         <font class="comment">// Factor M = QR = QDU where Q is orthogonal, D is diagonal,</font>
00745         <font class="comment">// and U is upper triangular with ones on its diagonal.  Algorithm uses</font>
00746         <font class="comment">// Gram-Schmidt orthogonalization (the QR algorithm).</font>
00747         <font class="comment">//</font>
00748         <font class="comment">// If M = [ m0 | m1 | m2 ] and Q = [ q0 | q1 | q2 ], then</font>
00749         <font class="comment">//</font>
00750         <font class="comment">//   q0 = m0/|m0|</font>
00751         <font class="comment">//   q1 = (m1-(q0*m1)q0)/|m1-(q0*m1)q0|</font>
00752         <font class="comment">//   q2 = (m2-(q0*m2)q0-(q1*m2)q1)/|m2-(q0*m2)q0-(q1*m2)q1|</font>
00753         <font class="comment">//</font>
00754         <font class="comment">// where |V| indicates length of vector V and A*B indicates dot</font>
00755         <font class="comment">// product of vectors A and B.  The matrix R has entries</font>
00756         <font class="comment">//</font>
00757         <font class="comment">//   r00 = q0*m0  r01 = q0*m1  r02 = q0*m2</font>
00758         <font class="comment">//   r10 = 0      r11 = q1*m1  r12 = q1*m2</font>
00759         <font class="comment">//   r20 = 0      r21 = 0      r22 = q2*m2</font>
00760         <font class="comment">//</font>
00761         <font class="comment">// so D = diag(r00,r11,r22) and U has entries u01 = r01/r00,</font>
00762         <font class="comment">// u02 = r02/r00, and u12 = r12/r11.</font>
00763 
00764         <font class="comment">// Q = rotation</font>
00765         <font class="comment">// D = scaling</font>
00766         <font class="comment">// U = shear</font>
00767 
00768         <font class="comment">// D stores the three diagonal entries r00, r11, r22</font>
00769         <font class="comment">// U stores the entries U[0] = u01, U[1] = u02, U[2] = u12</font>
00770 
00771         <font class="comment">// build orthogonal matrix Q</font>
00772         <a class="code" href="namespaceOgre.html#a281">Real</a> fInvLength = 1.0/Math::getSingleton().Sqrt(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]
00773             + <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0] +
00774             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0]);
00775         kQ[0][0] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]*fInvLength;
00776         kQ[1][0] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0]*fInvLength;
00777         kQ[2][0] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0]*fInvLength;
00778 
00779         <a class="code" href="namespaceOgre.html#a281">Real</a> fDot = kQ[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1] + kQ[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] +
00780             kQ[2][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1];
00781         kQ[0][1] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1]-fDot*kQ[0][0];
00782         kQ[1][1] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]-fDot*kQ[1][0];
00783         kQ[2][1] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1]-fDot*kQ[2][0];
00784         fInvLength = 1.0/Math::getSingleton().Sqrt(kQ[0][1]*kQ[0][1] + kQ[1][1]*kQ[1][1] +
00785             kQ[2][1]*kQ[2][1]);
00786         kQ[0][1] *= fInvLength;
00787         kQ[1][1] *= fInvLength;
00788         kQ[2][1] *= fInvLength;
00789 
00790         fDot = kQ[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] + kQ[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] +
00791             kQ[2][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
00792         kQ[0][2] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]-fDot*kQ[0][0];
00793         kQ[1][2] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2]-fDot*kQ[1][0];
00794         kQ[2][2] = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2]-fDot*kQ[2][0];
00795         fDot = kQ[0][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] + kQ[1][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] +
00796             kQ[2][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
00797         kQ[0][2] -= fDot*kQ[0][1];
00798         kQ[1][2] -= fDot*kQ[1][1];
00799         kQ[2][2] -= fDot*kQ[2][1];
00800         fInvLength = 1.0/Math::getSingleton().Sqrt(kQ[0][2]*kQ[0][2] + kQ[1][2]*kQ[1][2] +
00801             kQ[2][2]*kQ[2][2]);
00802         kQ[0][2] *= fInvLength;
00803         kQ[1][2] *= fInvLength;
00804         kQ[2][2] *= fInvLength;
00805 
00806         <font class="comment">// guarantee that orthogonal matrix has determinant 1 (no reflections)</font>
00807         <a class="code" href="namespaceOgre.html#a281">Real</a> fDet = kQ[0][0]*kQ[1][1]*kQ[2][2] + kQ[0][1]*kQ[1][2]*kQ[2][0] +
00808             kQ[0][2]*kQ[1][0]*kQ[2][1] - kQ[0][2]*kQ[1][1]*kQ[2][0] -
00809             kQ[0][1]*kQ[1][0]*kQ[2][2] - kQ[0][0]*kQ[1][2]*kQ[2][1];
00810 
00811         <font class="keywordflow">if</font> ( fDet &lt; 0.0 )
00812         {
00813             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
00814                 <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iCol = 0; iCol &lt; 3; iCol++)
00815                     kQ[iRow][iCol] = -kQ[iRow][iCol];
00816         }
00817 
00818         <font class="comment">// build "right" matrix R</font>
00819         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kR;
00820         kR[0][0] = kQ[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] + kQ[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0] +
00821             kQ[2][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0];
00822         kR[0][1] = kQ[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1] + kQ[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] +
00823             kQ[2][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1];
00824         kR[1][1] = kQ[0][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1] + kQ[1][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] +
00825             kQ[2][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1];
00826         kR[0][2] = kQ[0][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] + kQ[1][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] +
00827             kQ[2][0]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
00828         kR[1][2] = kQ[0][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] + kQ[1][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] +
00829             kQ[2][1]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
00830         kR[2][2] = kQ[0][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] + kQ[1][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] +
00831             kQ[2][2]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
00832 
00833         <font class="comment">// the scaling component</font>
00834         kD[0] = kR[0][0];
00835         kD[1] = kR[1][1];
00836         kD[2] = kR[2][2];
00837 
00838         <font class="comment">// the shear component</font>
00839         <a class="code" href="namespaceOgre.html#a281">Real</a> fInvD0 = 1.0/kD[0];
00840         kU[0] = kR[0][1]*fInvD0;
00841         kU[1] = kR[0][2]*fInvD0;
00842         kU[2] = kR[1][2]/kD[1];
00843     }
00844     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00845"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3e2">00845</a>     <a class="code" href="namespaceOgre.html#a281">Real</a> Matrix3::MaxCubicRoot (<a class="code" href="namespaceOgre.html#a281">Real</a> afCoeff[3])
00846     {
00847         <font class="comment">// Spectral norm is for A^T*A, so characteristic polynomial</font>
00848         <font class="comment">// P(x) = c[0]+c[1]*x+c[2]*x^2+x^3 has three positive real roots.</font>
00849         <font class="comment">// This yields the assertions c[0] &lt; 0 and c[2]*c[2] &gt;= 3*c[1].</font>
00850 
00851         <font class="comment">// quick out for uniform scale (triple root)</font>
00852         <font class="keyword">const</font> <a class="code" href="namespaceOgre.html#a281">Real</a> fOneThird = 1.0/3.0;
00853         <font class="keyword">const</font> <a class="code" href="namespaceOgre.html#a281">Real</a> fEpsilon = 1e-06;
00854         <a class="code" href="namespaceOgre.html#a281">Real</a> fDiscr = afCoeff[2]*afCoeff[2] - 3.0*afCoeff[1];
00855         <font class="keywordflow">if</font> ( fDiscr &lt;= fEpsilon )
00856             <font class="keywordflow">return</font> -fOneThird*afCoeff[2];
00857 
00858         <font class="comment">// Compute an upper bound on roots of P(x).  This assumes that A^T*A</font>
00859         <font class="comment">// has been scaled by its largest entry.</font>
00860         <a class="code" href="namespaceOgre.html#a281">Real</a> fX = 1.0;
00861         <a class="code" href="namespaceOgre.html#a281">Real</a> fPoly = afCoeff[0]+fX*(afCoeff[1]+fX*(afCoeff[2]+fX));
00862         <font class="keywordflow">if</font> ( fPoly &lt; 0.0 )
00863         {
00864             <font class="comment">// uses a matrix norm to find an upper bound on maximum root</font>
00865             fX = Math::getSingleton().Abs(afCoeff[0]);
00866             <a class="code" href="namespaceOgre.html#a281">Real</a> fTmp = 1.0+Math::getSingleton().Abs(afCoeff[1]);
00867             <font class="keywordflow">if</font> ( fTmp &gt; fX )
00868                 fX = fTmp;
00869             fTmp = 1.0+Math::getSingleton().Abs(afCoeff[2]);
00870             <font class="keywordflow">if</font> ( fTmp &gt; fX )
00871                 fX = fTmp;
00872         }
00873 
00874         <font class="comment">// Newton's method to find root</font>
00875         <a class="code" href="namespaceOgre.html#a281">Real</a> fTwoC2 = 2.0*afCoeff[2];
00876         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; 16; i++)
00877         {
00878             fPoly = afCoeff[0]+fX*(afCoeff[1]+fX*(afCoeff[2]+fX));
00879             <font class="keywordflow">if</font> ( Math::getSingleton().Abs(fPoly) &lt;= fEpsilon )
00880                 <font class="keywordflow">return</font> fX;
00881 
00882             <a class="code" href="namespaceOgre.html#a281">Real</a> fDeriv = afCoeff[1]+fX*(fTwoC2+3.0*fX);
00883             fX -= fPoly/fDeriv;
00884         }
00885 
00886         <font class="keywordflow">return</font> fX;
00887     }
00888     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00889"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a26">00889</a>     <a class="code" href="namespaceOgre.html#a281">Real</a> Matrix3::SpectralNorm ()<font class="keyword"> const</font>
00890 <font class="keyword">    </font>{
00891         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kP;
00892         <font class="keywordtype">int</font> iRow, iCol;
00893         <a class="code" href="namespaceOgre.html#a281">Real</a> fPmax = 0.0;
00894         <font class="keywordflow">for</font> (iRow = 0; iRow &lt; 3; iRow++)
00895         {
00896             <font class="keywordflow">for</font> (iCol = 0; iCol &lt; 3; iCol++)
00897             {
00898                 kP[iRow][iCol] = 0.0;
00899                 <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iMid = 0; iMid &lt; 3; iMid++)
00900                 {
00901                     kP[iRow][iCol] +=
00902                         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iMid][iRow]*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iMid][iCol];
00903                 }
00904                 <font class="keywordflow">if</font> ( kP[iRow][iCol] &gt; fPmax )
00905                     fPmax = kP[iRow][iCol];
00906             }
00907         }
00908 
00909         <a class="code" href="namespaceOgre.html#a281">Real</a> fInvPmax = 1.0/fPmax;
00910         <font class="keywordflow">for</font> (iRow = 0; iRow &lt; 3; iRow++)
00911         {
00912             <font class="keywordflow">for</font> (iCol = 0; iCol &lt; 3; iCol++)
00913                 kP[iRow][iCol] *= fInvPmax;
00914         }
00915 
00916         <a class="code" href="namespaceOgre.html#a281">Real</a> afCoeff[3];
00917         afCoeff[0] = -(kP[0][0]*(kP[1][1]*kP[2][2]-kP[1][2]*kP[2][1]) +
00918             kP[0][1]*(kP[2][0]*kP[1][2]-kP[1][0]*kP[2][2]) +
00919             kP[0][2]*(kP[1][0]*kP[2][1]-kP[2][0]*kP[1][1]));
00920         afCoeff[1] = kP[0][0]*kP[1][1]-kP[0][1]*kP[1][0] +
00921             kP[0][0]*kP[2][2]-kP[0][2]*kP[2][0] +
00922             kP[1][1]*kP[2][2]-kP[1][2]*kP[2][1];
00923         afCoeff[2] = -(kP[0][0]+kP[1][1]+kP[2][2]);
00924 
00925         <a class="code" href="namespaceOgre.html#a281">Real</a> fRoot = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3e2">MaxCubicRoot</a>(afCoeff);
00926         <a class="code" href="namespaceOgre.html#a281">Real</a> fNorm = Math::getSingleton().Sqrt(fPmax*fRoot);
00927         <font class="keywordflow">return</font> fNorm;
00928     }
00929     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l00930"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a27">00930</a>     <font class="keywordtype">void</font> Matrix3::ToAxisAngle (<a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; rkAxis, <a class="code" href="namespaceOgre.html#a281">Real</a>&amp; rfRadians)<font class="keyword"> const</font>
00931 <font class="keyword">    </font>{
00932         <font class="comment">// Let (x,y,z) be the unit-length axis and let A be an angle of rotation.</font>
00933         <font class="comment">// The rotation matrix is R = I + sin(A)*P + (1-cos(A))*P^2 where</font>
00934         <font class="comment">// I is the identity and</font>
00935         <font class="comment">//</font>
00936         <font class="comment">//       +-        -+</font>
00937         <font class="comment">//   P = |  0 -z +y |</font>
00938         <font class="comment">//       | +z  0 -x |</font>
00939         <font class="comment">//       | -y +x  0 |</font>
00940         <font class="comment">//       +-        -+</font>
00941         <font class="comment">//</font>
00942         <font class="comment">// If A &gt; 0, R represents a counterclockwise rotation about the axis in</font>
00943         <font class="comment">// the sense of looking from the tip of the axis vector towards the</font>
00944         <font class="comment">// origin.  Some algebra will show that</font>
00945         <font class="comment">//</font>
00946         <font class="comment">//   cos(A) = (trace(R)-1)/2  and  R - R^t = 2*sin(A)*P</font>
00947         <font class="comment">//</font>
00948         <font class="comment">// In the event that A = pi, R-R^t = 0 which prevents us from extracting</font>
00949         <font class="comment">// the axis through P.  Instead note that R = I+2*P^2 when A = pi, so</font>
00950         <font class="comment">// P^2 = (R-I)/2.  The diagonal entries of P^2 are x^2-1, y^2-1, and</font>
00951         <font class="comment">// z^2-1.  We can solve these for axis (x,y,z).  Because the angle is pi,</font>
00952         <font class="comment">// it does not matter which sign you choose on the square roots.</font>
00953 
00954         <a class="code" href="namespaceOgre.html#a281">Real</a> fTrace = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] + <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] + <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
00955         <a class="code" href="namespaceOgre.html#a281">Real</a> fCos = 0.5*(fTrace-1.0);
00956         rfRadians = Math::getSingleton().ACos(fCos);  <font class="comment">// in [0,PI]</font>
00957 
00958         <font class="keywordflow">if</font> ( rfRadians &gt; 0.0 )
00959         {
00960             <font class="keywordflow">if</font> ( rfRadians &lt; Math::getSingleton().PI )
00961             {
00962                 rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a> = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1]-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2];
00963                 rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a> = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0];
00964                 rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a> = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0]-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1];
00965                 rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3a24">normalise</a>();
00966             }
00967             <font class="keywordflow">else</font>
00968             {
00969                 <font class="comment">// angle is PI</font>
00970                 <font class="keywordtype">float</font> fHalfInverse;
00971                 <font class="keywordflow">if</font> ( <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] &gt;= <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] )
00972                 {
00973                     <font class="comment">// r00 &gt;= r11</font>
00974                     <font class="keywordflow">if</font> ( <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] &gt;= <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] )
00975                     {
00976                         <font class="comment">// r00 is maximum diagonal term</font>
00977                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a> = 0.5*Math::getSingleton().Sqrt(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] -
00978                             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] - <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] + 1.0);
00979                         fHalfInverse = 0.5/rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a>;
00980                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a> = fHalfInverse*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1];
00981                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a> = fHalfInverse*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2];
00982                     }
00983                     <font class="keywordflow">else</font>
00984                     {
00985                         <font class="comment">// r22 is maximum diagonal term</font>
00986                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a> = 0.5*Math::getSingleton().Sqrt(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] -
00987                             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] - <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] + 1.0);
00988                         fHalfInverse = 0.5/rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a>;
00989                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a> = fHalfInverse*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2];
00990                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a> = fHalfInverse*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2];
00991                     }
00992                 }
00993                 <font class="keywordflow">else</font>
00994                 {
00995                     <font class="comment">// r11 &gt; r00</font>
00996                     <font class="keywordflow">if</font> ( <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] &gt;= <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] )
00997                     {
00998                         <font class="comment">// r11 is maximum diagonal term</font>
00999                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a> = 0.5*Math::getSingleton().Sqrt(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] -
01000                             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] - <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] + 1.0);
01001                         fHalfInverse  = 0.5/rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a>;
01002                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a> = fHalfInverse*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1];
01003                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a> = fHalfInverse*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2];
01004                     }
01005                     <font class="keywordflow">else</font>
01006                     {
01007                         <font class="comment">// r22 is maximum diagonal term</font>
01008                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a> = 0.5*Math::getSingleton().Sqrt(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] -
01009                             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] - <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] + 1.0);
01010                         fHalfInverse = 0.5/rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a>;
01011                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a> = fHalfInverse*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2];
01012                         rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a> = fHalfInverse*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2];
01013                     }
01014                 }
01015             }
01016         }
01017         <font class="keywordflow">else</font>
01018         {
01019             <font class="comment">// The angle is 0 and the matrix is the identity.  Any axis will</font>
01020             <font class="comment">// work, so just use the x-axis.</font>
01021             rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a> = 1.0;
01022             rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a> = 0.0;
01023             rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a> = 0.0;
01024         }
01025     }
01026     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01027"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a28">01027</a>     <font class="keywordtype">void</font> Matrix3::FromAxisAngle (<font class="keyword">const</font> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; rkAxis, <a class="code" href="namespaceOgre.html#a281">Real</a> fRadians)
01028     {
01029         <a class="code" href="namespaceOgre.html#a281">Real</a> fCos = Math::getSingleton().Cos(fRadians);
01030         <a class="code" href="namespaceOgre.html#a281">Real</a> fSin = Math::getSingleton().Sin(fRadians);
01031         <a class="code" href="namespaceOgre.html#a281">Real</a> fOneMinusCos = 1.0-fCos;
01032         <a class="code" href="namespaceOgre.html#a281">Real</a> fX2 = rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a>*rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a>;
01033         <a class="code" href="namespaceOgre.html#a281">Real</a> fY2 = rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a>*rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a>;
01034         <a class="code" href="namespaceOgre.html#a281">Real</a> fZ2 = rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a>*rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a>;
01035         <a class="code" href="namespaceOgre.html#a281">Real</a> fXYM = rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a>*rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a>*fOneMinusCos;
01036         <a class="code" href="namespaceOgre.html#a281">Real</a> fXZM = rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a>*rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a>*fOneMinusCos;
01037         <a class="code" href="namespaceOgre.html#a281">Real</a> fYZM = rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a>*rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a>*fOneMinusCos;
01038         <a class="code" href="namespaceOgre.html#a281">Real</a> fXSin = rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m0">x</a>*fSin;
01039         <a class="code" href="namespaceOgre.html#a281">Real</a> fYSin = rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m1">y</a>*fSin;
01040         <a class="code" href="namespaceOgre.html#a281">Real</a> fZSin = rkAxis.<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3m2">z</a>*fSin;
01041 
01042         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] = fX2*fOneMinusCos+fCos;
01043         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1] = fXYM-fZSin;
01044         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] = fXZM+fYSin;
01045         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0] = fXYM+fZSin;
01046         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] = fY2*fOneMinusCos+fCos;
01047         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] = fYZM-fXSin;
01048         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0] = fXZM-fYSin;
01049         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1] = fYZM+fXSin;
01050         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] = fZ2*fOneMinusCos+fCos;
01051     }
01052     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01053"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a29">01053</a>     <font class="keywordtype">bool</font> Matrix3::ToEulerAnglesXYZ (<font class="keywordtype">float</font>&amp; rfYAngle, <font class="keywordtype">float</font>&amp; rfPAngle,
01054         <font class="keywordtype">float</font>&amp; rfRAngle)<font class="keyword"> const</font>
01055 <font class="keyword">    </font>{
01056         <font class="comment">// rot =  cy*cz          -cy*sz           sy</font>
01057         <font class="comment">//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx</font>
01058         <font class="comment">//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy</font>
01059 
01060         rfPAngle = Math::getSingleton().ASin(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]);
01061         <font class="keywordflow">if</font> ( rfPAngle &lt; Math::HALF_PI )
01062         {
01063             <font class="keywordflow">if</font> ( rfPAngle &gt; -Math::HALF_PI )
01064             {
01065                 rfYAngle = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2]);
01066                 rfRAngle = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]);
01067                 <font class="keywordflow">return</font> <font class="keyword">true</font>;
01068             }
01069             <font class="keywordflow">else</font>
01070             {
01071                 <font class="comment">// WARNING.  Not a unique solution.</font>
01072                 <font class="keywordtype">float</font> fRmY = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]);
01073                 rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01074                 rfYAngle = rfRAngle - fRmY;
01075                 <font class="keywordflow">return</font> <font class="keyword">false</font>;
01076             }
01077         }
01078         <font class="keywordflow">else</font>
01079         {
01080             <font class="comment">// WARNING.  Not a unique solution.</font>
01081             <font class="keywordtype">float</font> fRpY = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]);
01082             rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01083             rfYAngle = fRpY - rfRAngle;
01084             <font class="keywordflow">return</font> <font class="keyword">false</font>;
01085         }
01086     }
01087     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01088"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a30">01088</a>     <font class="keywordtype">bool</font> Matrix3::ToEulerAnglesXZY (<font class="keywordtype">float</font>&amp; rfYAngle, <font class="keywordtype">float</font>&amp; rfPAngle,
01089         <font class="keywordtype">float</font>&amp; rfRAngle)<font class="keyword"> const</font>
01090 <font class="keyword">    </font>{
01091         <font class="comment">// rot =  cy*cz          -sz              cz*sy</font>
01092         <font class="comment">//        sx*sy+cx*cy*sz  cx*cz          -cy*sx+cx*sy*sz</font>
01093         <font class="comment">//       -cx*sy+cy*sx*sz  cz*sx           cx*cy+sx*sy*sz</font>
01094 
01095         rfPAngle = Math::getSingleton().ASin(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1]);
01096         <font class="keywordflow">if</font> ( rfPAngle &lt; Math::HALF_PI )
01097         {
01098             <font class="keywordflow">if</font> ( rfPAngle &gt; -Math::HALF_PI )
01099             {
01100                 rfYAngle = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]);
01101                 rfRAngle = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]);
01102                 <font class="keywordflow">return</font> <font class="keyword">true</font>;
01103             }
01104             <font class="keywordflow">else</font>
01105             {
01106                 <font class="comment">// WARNING.  Not a unique solution.</font>
01107                 <font class="keywordtype">float</font> fRmY = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2]);
01108                 rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01109                 rfYAngle = rfRAngle - fRmY;
01110                 <font class="keywordflow">return</font> <font class="keyword">false</font>;
01111             }
01112         }
01113         <font class="keywordflow">else</font>
01114         {
01115             <font class="comment">// WARNING.  Not a unique solution.</font>
01116             <font class="keywordtype">float</font> fRpY = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2]);
01117             rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01118             rfYAngle = fRpY - rfRAngle;
01119             <font class="keywordflow">return</font> <font class="keyword">false</font>;
01120         }
01121     }
01122     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01123"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a31">01123</a>     <font class="keywordtype">bool</font> Matrix3::ToEulerAnglesYXZ (<font class="keywordtype">float</font>&amp; rfYAngle, <font class="keywordtype">float</font>&amp; rfPAngle,
01124         <font class="keywordtype">float</font>&amp; rfRAngle)<font class="keyword"> const</font>
01125 <font class="keyword">    </font>{
01126         <font class="comment">// rot =  cy*cz+sx*sy*sz  cz*sx*sy-cy*sz  cx*sy</font>
01127         <font class="comment">//        cx*sz           cx*cz          -sx</font>
01128         <font class="comment">//       -cz*sy+cy*sx*sz  cy*cz*sx+sy*sz  cx*cy</font>
01129 
01130         rfPAngle = Math::getSingleton().ASin(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2]);
01131         <font class="keywordflow">if</font> ( rfPAngle &lt; Math::HALF_PI )
01132         {
01133             <font class="keywordflow">if</font> ( rfPAngle &gt; -Math::HALF_PI )
01134             {
01135                 rfYAngle = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2]);
01136                 rfRAngle = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]);
01137                 <font class="keywordflow">return</font> <font class="keyword">true</font>;
01138             }
01139             <font class="keywordflow">else</font>
01140             {
01141                 <font class="comment">// WARNING.  Not a unique solution.</font>
01142                 <font class="keywordtype">float</font> fRmY = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]);
01143                 rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01144                 rfYAngle = rfRAngle - fRmY;
01145                 <font class="keywordflow">return</font> <font class="keyword">false</font>;
01146             }
01147         }
01148         <font class="keywordflow">else</font>
01149         {
01150             <font class="comment">// WARNING.  Not a unique solution.</font>
01151             <font class="keywordtype">float</font> fRpY = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]);
01152             rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01153             rfYAngle = fRpY - rfRAngle;
01154             <font class="keywordflow">return</font> <font class="keyword">false</font>;
01155         }
01156     }
01157     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01158"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a32">01158</a>     <font class="keywordtype">bool</font> Matrix3::ToEulerAnglesYZX (<font class="keywordtype">float</font>&amp; rfYAngle, <font class="keywordtype">float</font>&amp; rfPAngle,
01159         <font class="keywordtype">float</font>&amp; rfRAngle)<font class="keyword"> const</font>
01160 <font class="keyword">    </font>{
01161         <font class="comment">// rot =  cy*cz           sx*sy-cx*cy*sz  cx*sy+cy*sx*sz</font>
01162         <font class="comment">//        sz              cx*cz          -cz*sx</font>
01163         <font class="comment">//       -cz*sy           cy*sx+cx*sy*sz  cx*cy-sx*sy*sz</font>
01164 
01165         rfPAngle = Math::getSingleton().ASin(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0]);
01166         <font class="keywordflow">if</font> ( rfPAngle &lt; Math::HALF_PI )
01167         {
01168             <font class="keywordflow">if</font> ( rfPAngle &gt; -Math::HALF_PI )
01169             {
01170                 rfYAngle = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]);
01171                 rfRAngle = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]);
01172                 <font class="keywordflow">return</font> <font class="keyword">true</font>;
01173             }
01174             <font class="keywordflow">else</font>
01175             {
01176                 <font class="comment">// WARNING.  Not a unique solution.</font>
01177                 <font class="keywordtype">float</font> fRmY = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2]);
01178                 rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01179                 rfYAngle = rfRAngle - fRmY;
01180                 <font class="keywordflow">return</font> <font class="keyword">false</font>;
01181             }
01182         }
01183         <font class="keywordflow">else</font>
01184         {
01185             <font class="comment">// WARNING.  Not a unique solution.</font>
01186             <font class="keywordtype">float</font> fRpY = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2]);
01187             rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01188             rfYAngle = fRpY - rfRAngle;
01189             <font class="keywordflow">return</font> <font class="keyword">false</font>;
01190         }
01191     }
01192     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01193"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a33">01193</a>     <font class="keywordtype">bool</font> Matrix3::ToEulerAnglesZXY (<font class="keywordtype">float</font>&amp; rfYAngle, <font class="keywordtype">float</font>&amp; rfPAngle,
01194         <font class="keywordtype">float</font>&amp; rfRAngle)<font class="keyword"> const</font>
01195 <font class="keyword">    </font>{
01196         <font class="comment">// rot =  cy*cz-sx*sy*sz -cx*sz           cz*sy+cy*sx*sz</font>
01197         <font class="comment">//        cz*sx*sy+cy*sz  cx*cz          -cy*cz*sx+sy*sz</font>
01198         <font class="comment">//       -cx*sy           sx              cx*cy</font>
01199 
01200         rfPAngle = Math::getSingleton().ASin(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1]);
01201         <font class="keywordflow">if</font> ( rfPAngle &lt; Math::HALF_PI )
01202         {
01203             <font class="keywordflow">if</font> ( rfPAngle &gt; -Math::HALF_PI )
01204             {
01205                 rfYAngle = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1]);
01206                 rfRAngle = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2]);
01207                 <font class="keywordflow">return</font> <font class="keyword">true</font>;
01208             }
01209             <font class="keywordflow">else</font>
01210             {
01211                 <font class="comment">// WARNING.  Not a unique solution.</font>
01212                 <font class="keywordtype">float</font> fRmY = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]);
01213                 rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01214                 rfYAngle = rfRAngle - fRmY;
01215                 <font class="keywordflow">return</font> <font class="keyword">false</font>;
01216             }
01217         }
01218         <font class="keywordflow">else</font>
01219         {
01220             <font class="comment">// WARNING.  Not a unique solution.</font>
01221             <font class="keywordtype">float</font> fRpY = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]);
01222             rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01223             rfYAngle = fRpY - rfRAngle;
01224             <font class="keywordflow">return</font> <font class="keyword">false</font>;
01225         }
01226     }
01227     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01228"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a34">01228</a>     <font class="keywordtype">bool</font> Matrix3::ToEulerAnglesZYX (<font class="keywordtype">float</font>&amp; rfYAngle, <font class="keywordtype">float</font>&amp; rfPAngle,
01229         <font class="keywordtype">float</font>&amp; rfRAngle)<font class="keyword"> const</font>
01230 <font class="keyword">    </font>{
01231         <font class="comment">// rot =  cy*cz           cz*sx*sy-cx*sz  cx*cz*sy+sx*sz</font>
01232         <font class="comment">//        cy*sz           cx*cz+sx*sy*sz -cz*sx+cx*sy*sz</font>
01233         <font class="comment">//       -sy              cy*sx           cx*cy</font>
01234 
01235         rfPAngle = Math::getSingleton().ASin(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0]);
01236         <font class="keywordflow">if</font> ( rfPAngle &lt; Math::HALF_PI )
01237         {
01238             <font class="keywordflow">if</font> ( rfPAngle &gt; -Math::HALF_PI )
01239             {
01240                 rfYAngle = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0]);
01241                 rfRAngle = Math::getSingleton().ATan2(<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2]);
01242                 <font class="keywordflow">return</font> <font class="keyword">true</font>;
01243             }
01244             <font class="keywordflow">else</font>
01245             {
01246                 <font class="comment">// WARNING.  Not a unique solution.</font>
01247                 <font class="keywordtype">float</font> fRmY = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]);
01248                 rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01249                 rfYAngle = rfRAngle - fRmY;
01250                 <font class="keywordflow">return</font> <font class="keyword">false</font>;
01251             }
01252         }
01253         <font class="keywordflow">else</font>
01254         {
01255             <font class="comment">// WARNING.  Not a unique solution.</font>
01256             <font class="keywordtype">float</font> fRpY = Math::getSingleton().ATan2(-<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1],<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2]);
01257             rfRAngle = 0.0;  <font class="comment">// any angle works</font>
01258             rfYAngle = fRpY - rfRAngle;
01259             <font class="keywordflow">return</font> <font class="keyword">false</font>;
01260         }
01261     }
01262     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01263"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a35">01263</a>     <font class="keywordtype">void</font> Matrix3::FromEulerAnglesXYZ (<font class="keywordtype">float</font> fYAngle, <font class="keywordtype">float</font> fPAngle,
01264         <font class="keywordtype">float</font> fRAngle)
01265     {
01266         <a class="code" href="namespaceOgre.html#a281">Real</a> fCos, fSin;
01267 
01268         fCos = Math::getSingleton().Cos(fYAngle);
01269         fSin = Math::getSingleton().Sin(fYAngle);
01270         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kXMat(1.0,0.0,0.0,0.0,fCos,-fSin,0.0,fSin,fCos);
01271 
01272         fCos = Math::getSingleton().Cos(fPAngle);
01273         fSin = Math::getSingleton().Sin(fPAngle);
01274         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kYMat(fCos,0.0,fSin,0.0,1.0,0.0,-fSin,0.0,fCos);
01275 
01276         fCos = Math::getSingleton().Cos(fRAngle);
01277         fSin = Math::getSingleton().Sin(fRAngle);
01278         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kZMat(fCos,-fSin,0.0,fSin,fCos,0.0,0.0,0.0,1.0);
01279 
01280         *<font class="keyword">this</font> = kXMat*(kYMat*kZMat);
01281     }
01282     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01283"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a36">01283</a>     <font class="keywordtype">void</font> Matrix3::FromEulerAnglesXZY (<font class="keywordtype">float</font> fYAngle, <font class="keywordtype">float</font> fPAngle,
01284         <font class="keywordtype">float</font> fRAngle)
01285     {
01286         <a class="code" href="namespaceOgre.html#a281">Real</a> fCos, fSin;
01287 
01288         fCos = Math::getSingleton().Cos(fYAngle);
01289         fSin = Math::getSingleton().Sin(fYAngle);
01290         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kXMat(1.0,0.0,0.0,0.0,fCos,-fSin,0.0,fSin,fCos);
01291 
01292         fCos = Math::getSingleton().Cos(fPAngle);
01293         fSin = Math::getSingleton().Sin(fPAngle);
01294         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kZMat(fCos,-fSin,0.0,fSin,fCos,0.0,0.0,0.0,1.0);
01295 
01296         fCos = Math::getSingleton().Cos(fRAngle);
01297         fSin = Math::getSingleton().Sin(fRAngle);
01298         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kYMat(fCos,0.0,fSin,0.0,1.0,0.0,-fSin,0.0,fCos);
01299 
01300         *<font class="keyword">this</font> = kXMat*(kZMat*kYMat);
01301     }
01302     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01303"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a37">01303</a>     <font class="keywordtype">void</font> Matrix3::FromEulerAnglesYXZ (<font class="keywordtype">float</font> fYAngle, <font class="keywordtype">float</font> fPAngle,
01304         <font class="keywordtype">float</font> fRAngle)
01305     {
01306         <a class="code" href="namespaceOgre.html#a281">Real</a> fCos, fSin;
01307 
01308         fCos = Math::getSingleton().Cos(fYAngle);
01309         fSin = Math::getSingleton().Sin(fYAngle);
01310         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kYMat(fCos,0.0,fSin,0.0,1.0,0.0,-fSin,0.0,fCos);
01311 
01312         fCos = Math::getSingleton().Cos(fPAngle);
01313         fSin = Math::getSingleton().Sin(fPAngle);
01314         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kXMat(1.0,0.0,0.0,0.0,fCos,-fSin,0.0,fSin,fCos);
01315 
01316         fCos = Math::getSingleton().Cos(fRAngle);
01317         fSin = Math::getSingleton().Sin(fRAngle);
01318         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kZMat(fCos,-fSin,0.0,fSin,fCos,0.0,0.0,0.0,1.0);
01319 
01320         *<font class="keyword">this</font> = kYMat*(kXMat*kZMat);
01321     }
01322     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01323"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a38">01323</a>     <font class="keywordtype">void</font> Matrix3::FromEulerAnglesYZX (<font class="keywordtype">float</font> fYAngle, <font class="keywordtype">float</font> fPAngle,
01324         <font class="keywordtype">float</font> fRAngle)
01325     {
01326         <a class="code" href="namespaceOgre.html#a281">Real</a> fCos, fSin;
01327 
01328         fCos = Math::getSingleton().Cos(fYAngle);
01329         fSin = Math::getSingleton().Sin(fYAngle);
01330         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kYMat(fCos,0.0,fSin,0.0,1.0,0.0,-fSin,0.0,fCos);
01331 
01332         fCos = Math::getSingleton().Cos(fPAngle);
01333         fSin = Math::getSingleton().Sin(fPAngle);
01334         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kZMat(fCos,-fSin,0.0,fSin,fCos,0.0,0.0,0.0,1.0);
01335 
01336         fCos = Math::getSingleton().Cos(fRAngle);
01337         fSin = Math::getSingleton().Sin(fRAngle);
01338         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kXMat(1.0,0.0,0.0,0.0,fCos,-fSin,0.0,fSin,fCos);
01339 
01340         *<font class="keyword">this</font> = kYMat*(kZMat*kXMat);
01341     }
01342     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01343"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a39">01343</a>     <font class="keywordtype">void</font> Matrix3::FromEulerAnglesZXY (<font class="keywordtype">float</font> fYAngle, <font class="keywordtype">float</font> fPAngle,
01344         <font class="keywordtype">float</font> fRAngle)
01345     {
01346         <a class="code" href="namespaceOgre.html#a281">Real</a> fCos, fSin;
01347 
01348         fCos = Math::getSingleton().Cos(fYAngle);
01349         fSin = Math::getSingleton().Sin(fYAngle);
01350         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kZMat(fCos,-fSin,0.0,fSin,fCos,0.0,0.0,0.0,1.0);
01351 
01352         fCos = Math::getSingleton().Cos(fPAngle);
01353         fSin = Math::getSingleton().Sin(fPAngle);
01354         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kXMat(1.0,0.0,0.0,0.0,fCos,-fSin,0.0,fSin,fCos);
01355 
01356         fCos = Math::getSingleton().Cos(fRAngle);
01357         fSin = Math::getSingleton().Sin(fRAngle);
01358         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kYMat(fCos,0.0,fSin,0.0,1.0,0.0,-fSin,0.0,fCos);
01359 
01360         *<font class="keyword">this</font> = kZMat*(kXMat*kYMat);
01361     }
01362     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01363"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a40">01363</a>     <font class="keywordtype">void</font> Matrix3::FromEulerAnglesZYX (<font class="keywordtype">float</font> fYAngle, <font class="keywordtype">float</font> fPAngle,
01364         <font class="keywordtype">float</font> fRAngle)
01365     {
01366         <a class="code" href="namespaceOgre.html#a281">Real</a> fCos, fSin;
01367 
01368         fCos = Math::getSingleton().Cos(fYAngle);
01369         fSin = Math::getSingleton().Sin(fYAngle);
01370         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kZMat(fCos,-fSin,0.0,fSin,fCos,0.0,0.0,0.0,1.0);
01371 
01372         fCos = Math::getSingleton().Cos(fPAngle);
01373         fSin = Math::getSingleton().Sin(fPAngle);
01374         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kYMat(fCos,0.0,fSin,0.0,1.0,0.0,-fSin,0.0,fCos);
01375 
01376         fCos = Math::getSingleton().Cos(fRAngle);
01377         fSin = Math::getSingleton().Sin(fRAngle);
01378         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kXMat(1.0,0.0,0.0,0.0,fCos,-fSin,0.0,fSin,fCos);
01379 
01380         *<font class="keyword">this</font> = kZMat*(kYMat*kXMat);
01381     }
01382     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01383"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3b0">01383</a>     <font class="keywordtype">void</font> Matrix3::Tridiagonal (<a class="code" href="namespaceOgre.html#a281">Real</a> afDiag[3], <a class="code" href="namespaceOgre.html#a281">Real</a> afSubDiag[3])
01384     {
01385         <font class="comment">// Householder reduction T = Q^t M Q</font>
01386         <font class="comment">//   Input:</font>
01387         <font class="comment">//     mat, symmetric 3x3 matrix M</font>
01388         <font class="comment">//   Output:</font>
01389         <font class="comment">//     mat, orthogonal matrix Q</font>
01390         <font class="comment">//     diag, diagonal entries of T</font>
01391         <font class="comment">//     subd, subdiagonal entries of T (T is symmetric)</font>
01392 
01393         <a class="code" href="namespaceOgre.html#a281">Real</a> fA = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0];
01394         <a class="code" href="namespaceOgre.html#a281">Real</a> fB = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1];
01395         <a class="code" href="namespaceOgre.html#a281">Real</a> fC = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2];
01396         <a class="code" href="namespaceOgre.html#a281">Real</a> fD = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1];
01397         <a class="code" href="namespaceOgre.html#a281">Real</a> fE = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2];
01398         <a class="code" href="namespaceOgre.html#a281">Real</a> fF = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2];
01399 
01400         afDiag[0] = fA;
01401         afSubDiag[2] = 0.0;
01402         <font class="keywordflow">if</font> ( Math::getSingleton().Abs(fC) &gt;= <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3p0">EPSILON</a> )
01403         {
01404             <a class="code" href="namespaceOgre.html#a281">Real</a> fLength = Math::getSingleton().Sqrt(fB*fB+fC*fC);
01405             <a class="code" href="namespaceOgre.html#a281">Real</a> fInvLength = 1.0/fLength;
01406             fB *= fInvLength;
01407             fC *= fInvLength;
01408             <a class="code" href="namespaceOgre.html#a281">Real</a> fQ = 2.0*fB*fE+fC*(fF-fD);
01409             afDiag[1] = fD+fC*fQ;
01410             afDiag[2] = fF-fC*fQ;
01411             afSubDiag[0] = fLength;
01412             afSubDiag[1] = fE-fB*fQ;
01413             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] = 1.0;
01414             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1] = 0.0;
01415             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] = 0.0;
01416             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0] = 0.0;
01417             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] = fB;
01418             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] = fC;
01419             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0] = 0.0;
01420             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1] = fC;
01421             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] = -fB;
01422         }
01423         <font class="keywordflow">else</font>
01424         {
01425             afDiag[1] = fD;
01426             afDiag[2] = fF;
01427             afSubDiag[0] = fB;
01428             afSubDiag[1] = fE;
01429             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][0] = 1.0;
01430             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][1] = 0.0;
01431             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[0][2] = 0.0;
01432             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][0] = 0.0;
01433             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][1] = 1.0;
01434             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[1][2] = 0.0;
01435             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][0] = 0.0;
01436             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][1] = 0.0;
01437             <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[2][2] = 1.0;
01438         }
01439     }
01440     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01441"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3b1">01441</a>     <font class="keywordtype">bool</font> Matrix3::QLAlgorithm (<a class="code" href="namespaceOgre.html#a281">Real</a> afDiag[3], <a class="code" href="namespaceOgre.html#a281">Real</a> afSubDiag[3])
01442     {
01443         <font class="comment">// QL iteration with implicit shifting to reduce matrix from tridiagonal</font>
01444         <font class="comment">// to diagonal</font>
01445 
01446         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i0 = 0; i0 &lt; 3; i0++)
01447         {
01448             <font class="keyword">const</font> <font class="keywordtype">int</font> iMaxIter = 32;
01449             <font class="keywordtype">int</font> iIter;
01450             <font class="keywordflow">for</font> (iIter = 0; iIter &lt; iMaxIter; iIter++)
01451             {
01452                 <font class="keywordtype">int</font> i1;
01453                 <font class="keywordflow">for</font> (i1 = i0; i1 &lt;= 1; i1++)
01454                 {
01455                     <a class="code" href="namespaceOgre.html#a281">Real</a> fSum = Math::getSingleton().Abs(afDiag[i1]) +
01456                         Math::getSingleton().Abs(afDiag[i1+1]);
01457                     <font class="keywordflow">if</font> ( Math::getSingleton().Abs(afSubDiag[i1]) + fSum == fSum )
01458                         <font class="keywordflow">break</font>;
01459                 }
01460                 <font class="keywordflow">if</font> ( i1 == i0 )
01461                     <font class="keywordflow">break</font>;
01462 
01463                 <a class="code" href="namespaceOgre.html#a281">Real</a> fTmp0 = (afDiag[i0+1]-afDiag[i0])/(2.0*afSubDiag[i0]);
01464                 <a class="code" href="namespaceOgre.html#a281">Real</a> fTmp1 = Math::getSingleton().Sqrt(fTmp0*fTmp0+1.0);
01465                 <font class="keywordflow">if</font> ( fTmp0 &lt; 0.0 )
01466                     fTmp0 = afDiag[i1]-afDiag[i0]+afSubDiag[i0]/(fTmp0-fTmp1);
01467                 <font class="keywordflow">else</font>
01468                     fTmp0 = afDiag[i1]-afDiag[i0]+afSubDiag[i0]/(fTmp0+fTmp1);
01469                 <a class="code" href="namespaceOgre.html#a281">Real</a> fSin = 1.0;
01470                 <a class="code" href="namespaceOgre.html#a281">Real</a> fCos = 1.0;
01471                 <a class="code" href="namespaceOgre.html#a281">Real</a> fTmp2 = 0.0;
01472                 <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i2 = i1-1; i2 &gt;= i0; i2--)
01473                 {
01474                     <a class="code" href="namespaceOgre.html#a281">Real</a> fTmp3 = fSin*afSubDiag[i2];
01475                     <a class="code" href="namespaceOgre.html#a281">Real</a> fTmp4 = fCos*afSubDiag[i2];
01476                     <font class="keywordflow">if</font> ( Math::getSingleton().Abs(fTmp3) &gt;= Math::getSingleton().Abs(fTmp0) )
01477                     {
01478                         fCos = fTmp0/fTmp3;
01479                         fTmp1 = Math::getSingleton().Sqrt(fCos*fCos+1.0);
01480                         afSubDiag[i2+1] = fTmp3*fTmp1;
01481                         fSin = 1.0/fTmp1;
01482                         fCos *= fSin;
01483                     }
01484                     <font class="keywordflow">else</font>
01485                     {
01486                         fSin = fTmp3/fTmp0;
01487                         fTmp1 = Math::getSingleton().Sqrt(fSin*fSin+1.0);
01488                         afSubDiag[i2+1] = fTmp0*fTmp1;
01489                         fCos = 1.0/fTmp1;
01490                         fSin *= fCos;
01491                     }
01492                     fTmp0 = afDiag[i2+1]-fTmp2;
01493                     fTmp1 = (afDiag[i2]-fTmp0)*fSin+2.0*fTmp4*fCos;
01494                     fTmp2 = fSin*fTmp1;
01495                     afDiag[i2+1] = fTmp0+fTmp2;
01496                     fTmp0 = fCos*fTmp1-fTmp4;
01497 
01498                     <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
01499                     {
01500                         fTmp3 = <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][i2+1];
01501                         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][i2+1] = fSin*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][i2] +
01502                             fCos*fTmp3;
01503                         <a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][i2] = fCos*<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3n0">m</a>[iRow][i2] -
01504                             fSin*fTmp3;
01505                     }
01506                 }
01507                 afDiag[i0] -= fTmp2;
01508                 afSubDiag[i0] = fTmp0;
01509                 afSubDiag[i1] = 0.0;
01510             }
01511 
01512             <font class="keywordflow">if</font> ( iIter == iMaxIter )
01513             {
01514                 <font class="comment">// should not get here under normal circumstances</font>
01515                 <font class="keywordflow">return</font> <font class="keyword">false</font>;
01516             }
01517         }
01518 
01519         <font class="keywordflow">return</font> <font class="keyword">true</font>;
01520     }
01521     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01522"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3a41">01522</a>     <font class="keywordtype">void</font> Matrix3::EigenSolveSymmetric (<a class="code" href="namespaceOgre.html#a281">Real</a> afEigenvalue[3],
01523         <a class="code" href="classOgre_1_1Vector3.html">Vector3</a> akEigenvector[3])<font class="keyword"> const</font>
01524 <font class="keyword">    </font>{
01525         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a> kMatrix = *<font class="keyword">this</font>;
01526         <a class="code" href="namespaceOgre.html#a281">Real</a> afSubDiag[3];
01527         kMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3b0">Tridiagonal</a>(afEigenvalue,afSubDiag);
01528         kMatrix.<a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3b1">QLAlgorithm</a>(afEigenvalue,afSubDiag);
01529 
01530         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; 3; i++)
01531         {
01532             akEigenvector[i][0] = kMatrix[0][i];
01533             akEigenvector[i][1] = kMatrix[1][i];
01534             akEigenvector[i][2] = kMatrix[2][i];
01535         }
01536 
01537         <font class="comment">// make eigenvectors form a right--handed system</font>
01538         <a class="code" href="classOgre_1_1Vector3.html">Vector3</a> kCross = akEigenvector[1].<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3a25">crossProduct</a>(akEigenvector[2]);
01539         <a class="code" href="namespaceOgre.html#a281">Real</a> fDet = akEigenvector[0].<a class="code" href="classOgre_1_1Vector3.html#Ogre_1_1Vector3a23">dotProduct</a>(kCross);
01540         <font class="keywordflow">if</font> ( fDet &lt; 0.0 )
01541         {
01542             akEigenvector[2][0] = - akEigenvector[2][0];
01543             akEigenvector[2][1] = - akEigenvector[2][1];
01544             akEigenvector[2][2] = - akEigenvector[2][2];
01545         }
01546     }
01547     <font class="comment">//-----------------------------------------------------------------------</font>
<a name="l01548"></a><a class="code" href="classOgre_1_1Matrix3.html#Ogre_1_1Matrix3d0">01548</a>     <font class="keywordtype">void</font> Matrix3::TensorProduct (<font class="keyword">const</font> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; rkU, <font class="keyword">const</font> <a class="code" href="classOgre_1_1Vector3.html">Vector3</a>&amp; rkV,
01549         <a class="code" href="classOgre_1_1Matrix3.html">Matrix3</a>&amp; rkProduct)
01550     {
01551         <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iRow = 0; iRow &lt; 3; iRow++)
01552         {
01553             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> iCol = 0; iCol &lt; 3; iCol++)
01554                 rkProduct[iRow][iCol] = rkU[iRow]*rkV[iCol];
01555         }
01556     }
01557     <font class="comment">//-----------------------------------------------------------------------</font>
01558 }
</pre></div><p>
Copyright &copy; 2002 by The OGRE Team<br />
<script type="text/javascript">
<!--//hide script from old browsers
document.write( "Last modified "+ document.lastModified );
//end hiding contents -->
</script>
</p>
</body>
</html>
