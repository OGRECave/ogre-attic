<html>
<head>
<title>Tutorial: Material Scripts</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<style type="text/css">
<!--
.MainHeader {  font-weight: bold; color: #FFFF33; background-color: #006600; font-size: 10pt}
body {  font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt; color: #CCFFCC; background-color: #003300}
.BorderHeader {  background-color: #999900; font-size: 8pt; font-weight: bold; color: #333300; text-align: center}
.MainContent { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt; color: #CCFFCC }
.BorderContent {  font-size: 8pt; color: #66CC33; border-color: black #666600 #666600; padding-top: 2px; padding-right: 2px; padding-bottom: 10px; padding-left: 2px; margin-bottom: 2px; border-style: solid; border-top-width: 0px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px}
a:link {  color: #FFFF00; text-decoration: underline}
a:hover {  color: #FFFFFF; text-decoration: underline}
a:visited {  color: #FFCC66; text-decoration: underline}
li {  color: #66CC33; list-style-type: circle; position: relative; left: -15px; clip:    rect(   )}
.NewsDate {  color: #CCFFCC; font-weight: bold}
td {  font-size: 10pt}
th {  font-size: 10pt}
.Annotation {  font-size: 10px}

H1 { text-align: center; }
A.qindex {}
A.qindexRef {}
A.el { text-decoration: none; font-weight: bold }
A.elRef { font-weight: bold }
A.code { text-decoration: none; font-weight: normal; color: #4444ee }
A.codeRef { font-weight: normal; color: #4444ee }
DL.el { margin-left: -1cm }
DIV.fragment { width: 100%; border: none; background-color: #003300 }
DIV.ah { background-color: black; margin-bottom: 3; margin-top: 3 }
TD.md { background-color: #006600 }
DIV.groupHeader { margin-left: 16; margin-top: 12; margin-bottom: 6; font-weight: bold }
DIV.groupText { margin-left: 16; font-style: italic; font-size: smaller }
FONT.keyword       { color: #008000 }
FONT.keywordtype   { color: #999920 }
FONT.keywordflow   { color: #e0FF00 }
FONT.comment       { color: #009900 }
FONT.preprocessor  { color: #809020 }
FONT.stringliteral { color: #002080 }
FONT.charliteral   { color: #008080 }

H3 {
    FONT-FAMILY: trebuchet ms,helvetica,arial
}

.ex {
    FONT-SIZE: 8pt; FONT-FAMILY: tahoma
}
CODE.keywordtype {
    COLOR: #00ccff
}
CODE.keyword {
    FONT-WEIGHT: bold; COLOR: #00ccff
}
CODE.fn {
    COLOR: white;
    FONT-WEIGHT: bold;
}
CODE.var {
    COLOR: #dcdcdc;
}
CODE.macro {
    COLOR: #809020;
    FONT-WEIGHT: bold;
}
CODE.comm {
    COLOR: lime
}
CODE.num {
    COLOR: purple
}
CODE.str {
    COLOR: #ffcc33;
    font-style: italic
}
.SectionHeader {  font-size: 14px; color: #FFFFCC; font-weight: bold}
.header {  font-size: 16px; font-weight: bold; color: #FFFFCC}
-->
</style> 
</head>

<body bgcolor="#FFFFFF" text="#000000">
<p align="center" class="header">OGRE (Object-Oriented Graphics Rendering Engine)</p><p align="center" class="header">Material 
Scripts</p><p align="left" class="MainHeader">&nbsp;</p><P ALIGN="LEFT" CLASS="header">Material 
Attributes </P><P ALIGN="LEFT">These attributes are valid within the outer braces 
of a material in a script. They must each be on their own line. Ordering is unimportant.</P><P><A NAME="ambient"></A><SPAN CLASS="SectionHeader">ambient</SPAN></P><P>Sets 
the ambient colour reflectance properties of this material. </P><P>Format: ambient 
&lt;red&gt; &lt;green&gt; &lt;blue&gt;<BR>NB valid colour values are between 0.0 
and 1.0.</P><P>Example: ambient 0.0 0.8 0.0</P><P>The base colour of a material 
is determined by how much red, green and blue light is reflects. This property 
determines how much ambient light (directionless global light) is reflected. The 
default is full white, meaning objects are completely globally illuminated. Reduce 
this if you want to see diffuse or specular light effects, or change the blend 
of colours to make the object have a base colour other than white. This setting 
has no effect if dynamic <A HREF="#lighting">lighting</A> is disabled using the 
'lighting off' attribute, or if any texture layer has a '<A HREF="#colour_op">colour_op</A> 
replace' attribute.</P><P>Default: ambient 1.0 1.0 1.0<BR></P><P CLASS="SectionHeader"><A NAME="diffuse"></A>diffuse</P><P>Sets 
the diffuse colour reflectance properties of this material. </P><P>Format: diffuse 
&lt;red&gt; &lt;green&gt; &lt;blue&gt;<BR>NB valid colour values are between 0.0 
and 1.0.</P><P>Example: diffuse 1.0 0.5 0.5</P><P>The base colour of a material 
is determined by how much red, green and blue light is reflects. This property 
determines how much diffuse light (light from instances of the Light class in 
the scene) is reflected. The default is full white, meaning objects reflect the 
maximum white light they can from Light objects. This setting has no effect if 
dynamic <A HREF="#lighting">lighting</A> is disabled using the 'lighting off' 
attribute, or if any texture layer has a '<A HREF="#colour_op">colour_op</A> replace' 
attribute.</P><P>Default: diffuse 1.0 1.0 1.0<BR></P><P CLASS="SectionHeader"><A NAME="specular"></A>specular</P><P>Sets 
the specular colour reflectance properties of this material. </P><P>Format: specular 
&lt;red&gt; &lt;green&gt; &lt;blue&gt; &lt;shininess&gt;<BR>NB valid colour values 
are between 0.0 and 1.0. Shininess can be any value greater than 0.</P><P>Example: 
specular 1.0 1.0 1.0 12.5</P><P>The base colour of a material is determined by 
how much red, green and blue light is reflects. This property determines how much 
specular light (highlights from instances of the Light class in the scene) is 
reflected. The default is to reflect no specular light. The colour of the specular 
highlights is determined by the colour parameters, and the size of the highlights 
by the separate shininess parameter. This setting has no effect if dynamic <A HREF="#lighting">lighting</A> 
is disabled using the 'lighting off' attribute, or if any texture layer has a 
'<A HREF="#colour_op">colour_op</A> replace' attribute.</P><P>Default: specular 
0.0 0.0 0.0 0.0<BR></P><P CLASS="SectionHeader"><A NAME="emissive"></A>emissive</P><P>Sets 
the amount of self-illumination an object has. </P><P>Format: emissive &lt;red&gt; 
&lt;green&gt; &lt;blue&gt; <BR>NB valid colour values are between 0.0 and 1.0. 
</P><P>Example: emissive 1.0 0.0 0.0</P><P>If an object is self-illuminating, 
it does not need external sources to light it, ambient or otherwise. It's like 
the object has it's own personal ambient light. Unlike the name suggests, this 
object doesn't act as a light source for other objects in the scene (if you want 
it to, you have to create a light which is centered on the object). This setting 
has no effect if dynamic <A HREF="#lighting">lighting</A> is disabled using the 
'lighting off' attribute, or if any texture layer has a '<A HREF="#colour_op">colour_op</A> 
replace' attribute.</P><P>Default: emissive 0.0 0.0 0.0<BR></P><P CLASS="SectionHeader"><A NAME="scene_blend"></A>scene_blend 
</P><P>Sets the kind of blending this material has with the existing contents 
of the scene. Wheras the texture blending operations seen in the TextureLayer 
class are concerned with blending between texture layers, this blending is about 
combining the output of the material as a whole with the existing contents of 
the rendering target. This blending therefore allows object transparency and other 
special effects. There are 2 formats, one using predefined blend types, the other 
allowing a roll-your-own approach using source and destination factors</P><P>Format1: 
scene_blend &lt;add|modulate|alpha_blend&gt;</P><P>Example: scene_blend add</P><P> 
This is the simpler form, where the most commonly used blending modes are enumerated 
using a single parameter. Valid &lt;blend_type&gt; parameters are:</P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">add</DIV></TD><TD WIDTH="90%" HEIGHT="19">The 
colour of the rendering output is added to the scene. Good for exposions, flares, 
lights, ghosts etc. Equivalent to 'scene_blend one one'.</TD></TR><TR><TD WIDTH="10%"><DIV ALIGN="CENTER">modulate</DIV></TD><TD WIDTH="90%">The 
colour of the rendering output is multiplied with the scene contents. Generally 
colours and darkens the scene, good for smoked glass, semi-transparent objects 
etc. Equivalent to 'scene_blend src_colour one_minus_src_colour'</TD></TR><TR><TD WIDTH="10%"><DIV ALIGN="CENTER">alpha_blend</DIV></TD><TD WIDTH="90%">The 
alpha value of the rendering output is used as a mask. Equivalent to 'scene_blend 
src_alpha one_minus_src_alpha'</TD></TR></TABLE><P>Format2: scene_blend &lt;src_factor&gt; 
&lt;dest_factor&gt;</P><P>Example: scene_blend one one_minus_dest_alpha</P><P>This 
version of the method allows complete control over the blending operation, by 
specifying the source and destination blending factors. The resulting colour which 
is written to the rendering target is (texture * sourceFactor) + (scene_pixel 
* destFactor). Valid values for both parameters are:</P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">one</DIV></TD><TD WIDTH="90%" HEIGHT="19">Constant 
value of 1.0</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">zero</DIV></TD><TD WIDTH="90%" HEIGHT="19">Constant 
value of 0.0</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">dest_colour</DIV></TD><TD WIDTH="90%" HEIGHT="19">The 
existing pixel colour</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">src_colour</DIV></TD><TD WIDTH="90%" HEIGHT="19">The 
texture pixel (texel) colour</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">one_minus_dest_colour</DIV></TD><TD WIDTH="90%" HEIGHT="19">1 
- (dest_colour)</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">one_minus_src_colour</DIV></TD><TD WIDTH="90%" HEIGHT="19">1 
- (src_colour)</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">dest_alpha</DIV></TD><TD WIDTH="90%" HEIGHT="19">The 
existing pixel alpha value</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">src_alpha</DIV></TD><TD WIDTH="90%" HEIGHT="19">The 
texel alpha value</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">one_minus_dest_alpha</DIV></TD><TD WIDTH="90%" HEIGHT="19">1 
- (dest_alpha)</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">one_minus_src_alpha</DIV></TD><TD WIDTH="90%" HEIGHT="19">1 
- (src_alpha)</TD></TR></TABLE><P>Default: scene_blend one zero (opaque)</P><P CLASS="SectionHeader"><A NAME="depth_check"></A>depth_check</P><P>Sets 
whether or not this material renders with depth-buffer checking on or not. </P><P>Format: 
depth_check &lt;on|off&gt;</P><P>If depth-buffer checking is on, whenever a pixel 
is about to be written to the frame buffer the depth buffer is checked to see 
if the pixel is in front of all other pixels written at that point. If not, the 
pixel is not written. If depth checking is off, pixels are written no matter what 
has been rendered before. Also see <A HREF="#depth_func">depth_func</A> for more 
advanced depth check configuration. </P><P>Default: depth_check on<BR></P><P CLASS="SectionHeader"><A NAME="depth_write"></A>depth_write</P><P>Sets 
whether or not this material renders with depth-buffer writing on or not. </P><P>Format: 
depth_write &lt;on|off&gt;</P><P>If depth-buffer writing is on, whenever a pixel 
is written to the frame buffer the depth buffer is updated with the depth value 
of that new pixel, thus affecting future rendering operations if future pixels 
are behind this one. If depth writing is off, pixels are written without updating 
the depth buffer. Depth writing should normally be on but can be turned off when 
rendering static backgrounds or when rendering a collection of transparent objects 
at the end of a scene so that they overlap each other correctly. </P><P>Default: 
depth_write on<BR></P><P CLASS="SectionHeader"><A NAME="depth_func"></A>depth_func</P><P>Sets 
the function used to compare depth values when depth checking is on. </P><P>Format: 
depth_func &lt;func&gt;</P><P>If depth checking is enabled (see <A HREF="#depth_check">depth_check</A>) 
a comparison occurs between the depth value of the pixel to be written and the 
current contents of the buffer. This comparison is normally less_equal, i.e. the 
pixel is written if it is closer (or at the same distance) than the current contents. 
The possible functions are:</P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">always_fail</DIV></TD><TD WIDTH="90%" HEIGHT="19"> 
Never writes a pixel to the render target</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">always_pass</DIV></TD><TD WIDTH="90%" HEIGHT="19">Always 
writes a pixel to the render target</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">less</DIV></TD><TD WIDTH="90%" HEIGHT="19">Write 
if (new_Z &lt; existing_Z)</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">less_equal</DIV></TD><TD WIDTH="90%" HEIGHT="19">Write 
if (new_Z &lt;= existing_Z)</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">equal</DIV></TD><TD WIDTH="90%" HEIGHT="19">Write 
if (new_Z == existing_Z)</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">not_equal</DIV></TD><TD WIDTH="90%" HEIGHT="19">Write 
if (new_Z != existing_Z)</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">greater_equal</DIV></TD><TD WIDTH="90%" HEIGHT="19">Write 
if (new_Z &gt;= existing_Z)</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">greater</DIV></TD><TD WIDTH="90%" HEIGHT="19">Write 
if (new_Z &gt;existing_Z)</TD></TR></TABLE><P>Default: depth_func less_equal</P><P CLASS="SectionHeader"><A NAME="depth_func"></A>depth_bias</P><P>Sets 
the bias applied to the depth value of this material. Can be used to make coplanar 
polygons appear on top of others e.g. for decals</P><P>Format: depth_bias &lt;value&gt;</P><P>Where 
&lt;value&gt; is between 0 and 16, the default being 0. The higher the value, 
the greater the offset (for if you want to do multiple overlapping decals).</P><P><BR></P><P CLASS="SectionHeader"><A NAME="cull_hardware"></A>cull_hardware</P><P>Sets 
the hardware culling mode for this material. </P><P>Format: cull_hardware &lt;clockwise|anitclockwise|none&gt;</P><P>A 
typical way for the hardware rendering engine to cull triangles is based on the 
'vertex winding' of triangles. Vertex winding refers to the direction in which 
the vertices are passed or indexed to in the rendering operation as viewed from 
the camera, and will wither be clockwise or anticlockwise (that's 'counterclockwise' 
for you Americans out there ;). If the option 'cull_hardware clockwise' is set, 
all triangles whose vertices are viewed in clockwise order from the camera will 
be culled by the hardware. 'anticlockwise' is the reverse (obviously), and 'none' 
turns off hardware culling so all triagles are rendered (useful for creating 2-sided 
materials).</P><P>Default: cull_hardware clockwise<BR>NB this is the same as OpenGL's 
default but the opposite of Direct3D's default (because Ogre uses a right-handed 
coordinate system like OpenGL). </P><P CLASS="SectionHeader"><A NAME="cull_software"></A>cull_software</P><P>Sets 
the software culling mode for this material.</P><P>Format: cull_software &lt;back|front|none&gt;</P><P>In 
some situations the engine will also cull geometry in software before sending 
it to the hardware renderer. This setting only takes effect on SceneManager's 
that use it (since it is best used on large groups of planar world geometry rather 
than on movable geometry since this would be expensive), but if used can cull 
geometry before it is sent to the hardware. In this case the culling is based 
on whether the 'back' or 'front' of the traingle is facing the camera - this definition 
is based on the face normal (a vector which sticks out of the front side of the 
polygon perpendicular to the face). Since Ogre expects face normals to be on anticlockwise 
side of the face, 'cull_software back' is the software equivalent of 'cull_hardware 
clockwise' setting, which is why they are both the default. The naming is different 
to reflect the way the culling is done though, since most of the time face normals 
are precalculated and they don't <I>have</I> to be the way Ogre expects - you 
could set 'cull_hardware none' and completely cull in software based on your own 
face normals, if you have the right SceneManager which uses them.</P><P>Default: 
cull_software back<BR></P><P CLASS="SectionHeader"><A NAME="lighting"></A>lighting</P><P>Sets 
whether or not dynamic lighting is turned on for this material or not. If lighting 
is turned off, all objects rendered using the material will be fully lit.</P><P>Format: 
lighting &lt;on|off&gt;</P><P>Turning dynamic lighting off makes any <A HREF="#ambient">ambient</A>, 
<A HREF="#diffuse">diffuse</A>, <A HREF="#specular">specular</A>, <A HREF="#emissive">emissive</A> 
and <A HREF="#shading">shading</A> properties for this material redundant. When 
lighting is turned on, objects are lit according to their vertex normals for diffuse 
and specular light, and globally for ambient and emissive.</P><P>Default: lighting 
on</P><P CLASS="SectionHeader"><A NAME="shading"></A>shading</P><P>Sets the kind 
of shading which should be used for representing dynamic lighting for this material.</P><P>Format: 
shading &lt;flat|gouraud|phong&gt;</P><P>When <A HREF="#lighting">dynamic lighting</A> 
is turned on, the effect is to generate colour values at each vertex. Whether 
these values are interpolated across the face (and how) depends on this setting. 
</P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">flat</DIV></TD><TD WIDTH="90%" HEIGHT="19"> 
No interpolation takes place. Each face is shaded with a single colour determined 
from the first vertex in the face.</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">gouraud</DIV></TD><TD WIDTH="90%" HEIGHT="19">Colour 
at each vertex is linearly interpolated across the face.</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">phong</DIV></TD><TD WIDTH="90%" HEIGHT="19">Vertex 
normals are interpolated across the face, and these are used to determine colour 
at each pixel. Gives a more natural lighting effect but is more expensive and 
works better at high levels of tesselation. Not supported on all hardware.</TD></TR></TABLE><P>Default: 
shading gouraud</P><P CLASS="SectionHeader"><A NAME="filtering"></A>filtering</P><P>Sets 
the type of texture filtering used when magnifying or minifying a texture. </P><P>Format: 
filtering &lt;none|bilinear|trilinear&gt;</P><P>Default: filtering bilinear</P><P CLASS="SectionHeader">&nbsp;</P><P CLASS="header">Texture 
Layer Attributes</P><P>Texture layers are added in order by including nested brace 
sections in the material. Any of the following attributes can be included in any 
order within these braces:</P><P><A NAME="texture"></A><SPAN CLASS="SectionHeader">texture</SPAN></P><P>Sets 
the name of the static texture image this layer will use.</P><P>Format: texture 
&lt;texturename&gt;</P><P>Example: texture funkywall.jpg</P><P>This setting is 
mutually exclusive with the <A HREF="#anim_texture">anim_texture</A> attribute. 
Note that the texture file cannot include spaces. Those of you Windows users who 
like spaces in filenames, please get over it and use underscores instead.</P><P>Default: 
none</P><P CLASS="SectionHeader"><A NAME="anim_texture"></A>anim_texture</P><P>Sets 
the images to be used in an animated texture layer. In this case an animated texture 
layer means one which has multiple frames, each of which is a separate image file. 
There are 2 formats, one for implicitly determined image names, one for explicitly 
named images.</P><P>Format1 (short): anim_texture &lt;base_name&gt; &lt;num_frames&gt; 
&lt;duration&gt;</P><P>Example: anim_texture flame.jpg 5 2.5<BR>This sets up an 
animated texture layer made up of 5 frames named flame_1.jpg, flame_2.jpg etc, 
with an animation length of 2.5 seconds (2fps). If duration is set to 0, then 
no automatic transition takes place and frames must be changed manually in code.</P><P>Format2 
(long): anim_texture &lt;frame1&gt; &lt;frame2&gt; ... &lt;duration&gt;</P><P>Example: 
anim_texture flamestart.jpg flamemore.png flameagain.jpg moreflame.jpg lastflame.tga 
2.5<BR>This sets up the same duration animation but from 5 separately named image 
files.</P><P>The first format is more concise, but the second is provided if you 
cannot make your images conform to the naming standard required for it.</P><P>Default: 
none</P><P CLASS="SectionHeader"><A NAME="cubic_texture"></A>cubic_texture</P><P>Sets 
the images used in a cubic texture, i.e. one made up of 6 individual images making 
up the faces of a cube. These kinds of textures are used for reflection maps (if 
hardware supports cubic reflection maps) or skyboxes. There are 2 formats, a brief 
format expecting image names of a particular format and a more flexible but longer 
format for arbitrarily named textures.</P><P>Format1 (short): cubic_texture &lt;base_name&gt; 
&lt;combinedUVW|separateUV&gt;</P><P>The base_name in this format is something 
like 'skybox.jpg', and the system will expect you to provide skybox_fr.jpg, skybox_bk.jpg, 
skybox_up.jpg, skybox_dn.jpg, skybox_lf.jpg, and skybox_rt.jpg for the individual 
faces.</P><P>Format2 (long): cubic_texture &lt;front&gt; &lt;back&gt; &lt;left&gt; 
&lt;right&gt; &lt;up&gt; &lt;down&gt; &lt;combinedUVW|separateUV&gt;</P><P>In 
this case each face is specified explicitly, incase you don't want to conform 
to the image naming standards above.</P><P>In both cases the final parameter means 
the following:</P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">combinedUVW</DIV></TD><TD WIDTH="90%" HEIGHT="19"> 
The 6 textures are combined into a single 'cubic' texture map which is then addressed 
using 3D texture coordinates with U, V and W components. Necessary for reflection 
maps since you never know which face of the box you are going to need. Note that 
not all cards support cubic environment mapping.</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">separateUV</DIV></TD><TD WIDTH="90%" HEIGHT="19">The 
6 textures are kept separate but are all referenced by this single texture layer. 
One texture at a time is active (they are actually stored as 6 frames), and they 
are addressed using standard 2D UV coordinates. This type is good for skyboxes 
since only one face is rendered at one time and this has more guaranteed hardware 
support on older cards.</TD></TR></TABLE><P>Default: none</P><P CLASS="SectionHeader"><A NAME="tex_coord_set"></A>tex_coord_set</P><P>Sets 
which texture coordinate set is to be used for this texture layer. A mesh can 
define multiple sets of texture coordinates, this sets which one this material 
uses.</P><P>Format: tex_coord_set &lt;set_num&gt;</P><P>Example: tex_coord_set 
2</P><P>Default: tex_coord_set 0</P><P CLASS="SectionHeader"><A NAME="tex_address_mode"></A>tex_address_mode</P><P>Defines 
what happens when texture coordinates exceed 1.0 for this texture layer.</P><P>Format: 
tex_address_mode &lt;wrap|clamp|mirror&gt;</P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">wrap</DIV></TD><TD WIDTH="90%" HEIGHT="19"> 
Any value beyond 1.0 wraps back to 0.0. Texture is repeated.</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">clamp</DIV></TD><TD WIDTH="90%" HEIGHT="19">Values 
beyond 1.0 are clamped to 1.0. Texture 'streaks' beyond 1.0 since last line of 
pixels is used across the rest of the address space. Useful for textures which 
need exact coverage from 0.0 to 1.0 without the 'fuzzy edge' wrap gives when combined 
with filtering.</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">mirror</DIV></TD><TD WIDTH="90%" HEIGHT="19">Texture 
flips every boundary, meaning texture is mirrored every 1.0 u or v</TD></TR></TABLE><P>Default: 
tex_address_mode wrap</P><P CLASS="SectionHeader"><A NAME="colour_op"></A>colour_op</P><P>Determines 
how the colour of this texture layer is combined with the one below it (or the 
lighting effect on the geometry if this is the first layer). </P><P>Format: colour_op 
&lt;replace|add|modulate|alpha_blend&gt; </P><P>This method is the simplest way 
to blend tetxure layers, because it requires only one parameter, gives you the 
most common blending types, and automatically sets up 2 blending methods: one 
for if single-pass multitexturing hardware is available, and another for if it 
is not and the blending must be achieved through multiple rendering passes. It 
is, however, quite limited and does not expose the more flexible multitexturing 
operations, simply because these can't be automatically supported in multipass 
fallback mode. If want to use the fancier options, use <A HREF="#colour_op_ex">colour_op_ex</A>, 
but you'll either have to be sure that enough multitexturing units will be available, 
or you should explicitly set a fallback using <A HREF="#colour_op_multipass_fallback">colour_op_multipass_fallback</A>. 
</P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">replace</DIV></TD><TD WIDTH="90%" HEIGHT="19"> 
Replace all colour with texture with no adjustment. </TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">add</DIV></TD><TD WIDTH="90%" HEIGHT="19">Add 
colour components together.</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">modulate</DIV></TD><TD WIDTH="90%" HEIGHT="19">Multiply 
colour components together.</TD></TR><TR><TD WIDTH="10%" HEIGHT="19"><DIV ALIGN="CENTER">alpha_blend</DIV></TD><TD WIDTH="90%" HEIGHT="19">Blend 
based on texture alpha.</TD></TR></TABLE><P>Default: colour_op modulate</P><P></P><P CLASS="SectionHeader"><A NAME="alpha_rejection"></A>alpha_rejection</P><P>Sets 
the way the layer will have use alpha to totally reject pixels from the pipeline. 
</P><P>Format: alpha_rejection &lt;function&gt; &lt;value&gt;</P><P>Example: alpha_rejection 
greater_equal 128</P><P>The function parameter can be any of the options listed 
in the material <A HREF="#depth_func">depth_function</A> attribute. The value 
parameter can theoretically be any value between 0 and 255, but is best limited 
to 0 or 128 for hardware compatibility.</P><P>Default: alpha_rejection always_pass</P><P></P><P CLASS="SectionHeader"><A NAME="colour_op_ex"></A>colour_op_ex</P><P>This 
is an extended version of the <A HREF="#colour_op">colour_op</A> attribute which 
allows extremely detailed control over the blending applied between this and earlier 
layers. Multitexturing hardware can apply more complex blending operations that 
multipass blendind, but you are limited to the number of texture units which are 
available in hardware.</P><P>Format: colour_op_ex &lt;operation&gt; &lt;source1&gt; 
&lt;source2&gt; [&lt;manual&gt;]</P><P>Example colour_op_ex add_signed src_manual 
src_current 0.5</P><P>See the IMPORTANT note below about the issues between mulitpass 
and multitexturing that using this method can create. Texture colour operations 
determine how the final colour of the surface appears when rendered. Texture units 
are used to combine colour values from various sources (e.g. the diffuse colour 
of the surface from lighting calculations, combined with the colour of the texture). 
This method allows you to specify the 'operation' to be used, i.e. the calculation 
such as adds or multiplies, and which values to use as arguments, such as a fixed 
value or a value from a previous calculation. </P><P><B>Operation options</B></P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">source1</DIV></TD><TD WIDTH="88%" HEIGHT="19"> 
Use source1 without modification</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">source2</DIV></TD><TD WIDTH="88%" HEIGHT="19">Use 
source2 without modification</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">modulate</DIV></TD><TD WIDTH="88%" HEIGHT="19">Multiply 
source1 and source2 together.</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">modulate_x2</DIV></TD><TD WIDTH="88%" HEIGHT="19">Multiply 
source1 and source2 together, then by 2 (brightening).</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">modulate_x4</DIV></TD><TD WIDTH="88%" HEIGHT="19">Multiply 
source1 and source2 together, then by 4 (brightening).</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">add</DIV></TD><TD WIDTH="88%" HEIGHT="19">Add 
source1 and source2 together.</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">add_signed</DIV></TD><TD WIDTH="88%" HEIGHT="19">Add 
source1 and source2 then subtract 0.5.</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">add_smooth</DIV></TD><TD WIDTH="88%" HEIGHT="19">Add 
source1 and source2, subtract the product</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">subtract</DIV></TD><TD WIDTH="88%" HEIGHT="19">Subtract 
source2 from source1</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">blend_diffuse_alpha</DIV></TD><TD WIDTH="88%" HEIGHT="19">Use 
interpolated alpha value from vertices to scale source1, then add source2 scaled 
by (1-alpha).</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">blend_texture_alpha</DIV></TD><TD WIDTH="88%" HEIGHT="19">As 
blend_diffuse_alpha but use alpha from texture</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">blend_current_alpha</DIV></TD><TD WIDTH="88%" HEIGHT="19">As 
blend_diffuse_alpha but use current alpha from previous stages (same as blend_diffuse_alpha 
for first layer)</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">blend_manual</DIV></TD><TD WIDTH="88%" HEIGHT="19">As 
blend_diffuse_alpha but use a constant manual alpha value specified in &lt;manual&gt;</TD></TR></TABLE><P><B>Source1 
and source2 options</B></P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">src_current</DIV></TD><TD WIDTH="88%" HEIGHT="19">The 
colour as built up from previous stages. </TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">src_texture</DIV></TD><TD WIDTH="88%" HEIGHT="19">The 
colour derived from the texture assigned to this layer.</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">src_diffuse</DIV></TD><TD WIDTH="88%" HEIGHT="19">The 
interpolated diffuse colour from the vertices (same as 'src_current' for first 
layer).</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">src_specular</DIV></TD><TD WIDTH="88%" HEIGHT="19">The 
interpolated specular colour from the vertices.</TD></TR></TABLE><P>For example 
'modulate' takes the colour results of the previous layer, and multiplies them 
with the new texture being applied. Bear in mind that colours are RGB values from 
0.0-1.0 so multiplying them together will result in values in the same range, 
'tinted' by the multiply. Note however that a straight multiply normally has the 
effect of darkening the textures - for this reason there are brightening operations 
like modulate_x2. <BR>Note that because of the limitations on some underlying 
APIs (Direct3D included) the 'texture' argument can only be used as the first 
argument, not the second. </P><P>Note that the last parameter is only required 
if you decide to pass a value manually into the operation. Hence you only need 
to fill these in if you use the 'blend_manual' operation. </P><P>IMPORTANT: Ogre 
tries to use multitexturing hardware to blend texture layers together. However, 
if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a GeForce3) it has 
to fall back on multipass rendering, i.e. rendering the same object multiple times 
with different textures. This is both less efficient and there is a smaller range 
of blending operations which can be performed. For this reason, if you use this 
method you really should set the <A HREF="#colour_op_multipass_fallback">colour_op_multipass_fallback</A> 
attribute to specify which effect you want to fall back on if sufficient hardware 
is not available (the default is just 'modulate' which is unlikely to be what 
you want if you're doing swanky blending here). If you wish to avoid having to 
do this, use the simpler <A HREF="#colour_op">colour_op</A> attribute which allows 
less flexible blending options but sets up the multipass fallback automatically, 
since it only allows operations which have direct multipass equivalents.</P><P>Default: 
none (colour_op modulate)</P><P CLASS="SectionHeader"><A NAME="colour_op_multipass_fallback"></A>colour_op_multipass_fallback</P><P>Sets 
the multipass fallback operation for this layer, if you used <A HREF="#colour_op_ex">colour_op_ex</A> 
and not enough multitexturing hardware is available. </P><P>Format: colour_op_multipass_fallback 
&lt;src_factor&gt; &lt;dest_factor&gt;</P><P>Example: colour_op_mulitpass_fallback 
one one_minus_dest_alpha</P><P>Because some of the effects you can create using 
<A HREF="#colour_op_ex">colour_op_ex</A> are only supported under multitexturing 
hardware, if the hardware is lacking the system must fallback on multipass rendering, 
which unfortunately doesn't support as many effects. This attribute is for you 
to specify the fallback operation which most suits you. </P><P>The parameters 
are the same as in the <A HREF="#scene_blend">scene_blend</A> attribute; this 
is because multipass rendering IS effectively scene blending, since each layer 
is rendered on top of the last using the same mechanism as making an object transparent, 
it's just being rendered in the same place repeatedly to get the multitexture 
effect. If you use the simpler (and less flexible) <A HREF="#colour_op">colour_op</A> 
attribute you don't need to call this as the system sets up the fallback for you. 
<BR></P><P></P><P CLASS="SectionHeader"><A NAME="alpha_op_ex"></A>alpha_op_ex</P><P>Behaves 
in exactly the same away as <A HREF="#colour_op_ex">colour_op_ex</A> except that 
it determines how alpha values are combined between texture layers rather than 
colour values.</P><P CLASS="SectionHeader"><A NAME="env_map"></A>env_map</P><P>Turns 
on/off texture coordinate effect that makes this layer an environment map. </P><P>Format: 
env_map &lt;off|spherical|planar|cubic&gt;</P><P>Environment maps make an object 
look reflective by using automatic texture coordinate generation depending on 
the relationship between the objects vertices or normals and the eye. </P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">spherical</DIV></TD><TD WIDTH="88%" HEIGHT="19">A 
spherical environment map. Requires a single texture which is either a fish-eye 
lens view of the reflected scene, or some other texture which looks good as a 
spherical map (a texture of glossy highlights is popular especially in car sims). 
This effect is based on the relationship between the eye direction and the vertex 
normals of the object, so works best when there are a lot of gradually changing 
normals, i.e. curved objects.</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">planar</DIV></TD><TD WIDTH="88%" HEIGHT="19">Similar 
to the spherical environment map, but the effect is based on the position of the 
vertices in the viewport rather than vertex normals. This effect is therefore 
useful for planar geometry (where a spherical env_map would not look good because 
the normals are all the same) or objects without normals.</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">cubic</DIV></TD><TD WIDTH="88%" HEIGHT="19">Not 
yet supported but will be the same as spherical except that instead of a single 
fish-eye lens reflection map, it uses a group of 6 textures making up the inside 
of a cube, each of which is a view if the scene down each axis. Uses the camera-to-normal 
generation effect so good for curved geometry.</TD></TR></TABLE><P>&nbsp;</P><P>Default: 
env_map off</P><P></P><P CLASS="SectionHeader"><A NAME="scroll"></A>scroll</P><P>Sets 
a fixed scroll offset for the texture.</P><P>Format: scroll &lt;x&gt; &lt;y&gt;</P><P>This 
method offsets the texture in this layer by a fixed amount. Useful for small adjustments 
without altering texture coordinates in models. However if you wish to have an 
animated scroll effect, see the <A HREF="#scroll_anim">scroll_anim</A> attribute.</P><P CLASS="SectionHeader"><A NAME="scroll_anim"></A>scroll_anim</P><P>Sets 
up an animated scroll for the texture layer. Useful for creating fixed-speed scrolling 
effects on a texture layer (for varying scroll speeds, see <A HREF="#wave_xform">wave_xform</A>). 
</P><P>Format: scroll_anim &lt;xspeed&gt; &lt;yspeed&gt;<BR></P><P CLASS="SectionHeader"><A NAME="rotate"></A>rotate</P><P>Rotates 
a texture to a fixed angle. This attribute changes the rotational orientation 
of a texture to a fixed angle, useful for fixed adjustments. If you wish to animate 
the rotation, see <A HREF="#rotate_anim">rotate_anim</A>.</P><P>Format: rotate 
&lt;angle&gt;</P><P>The parameter is a anticlockwise angle in degrees. </P><P CLASS="SectionHeader"><A NAME="rotate_anim"></A>rotate_anim</P><P>Sets 
up an animated rotation effect of this layer. Useful for creating fixed-speed 
rotation animations (for varying speeds, see <A HREF="#wave_xform">wave_xform</A>).</P><P>Format: 
rotate_anim &lt;revs_per_second&gt;</P><P>The parameter is a number of anticlockwise 
revolutions per second.</P><P CLASS="SectionHeader"><A NAME="scale"></A>scale</P><P>Adjusts 
the scaling factor applied to this texture layer. Useful for adjusting the size 
of textures without making changes to geometry. This is a fixed scaling factor, 
if you wish to animate this see <A HREF="#wave_xform">wave_xform</A>.</P><P>Format: 
scale &lt;x_scale&gt; &lt;y_scale&gt;</P><P>Valid scale values are greater than 
0, with a scale factor of 2 making the texture twice as big in that dimension 
etc. </P><P CLASS="SectionHeader"><A NAME="wave_xform"></A>wave_xform</P><P>Sets 
up a transformation animation based on a wave function. Useful for more advanced 
texture layer transform effects. You can add multiple instances of this attribute 
to a single texture layer if you wish.</P><P>Format: wave_xform &lt;xform_type&gt; 
&lt;wave_type&gt; &lt;base&gt; &lt;frequency&gt; &lt;phase&gt; &lt;amplitude&gt;</P><P>Example: 
wave_xform scale_x sine 1.0 0.2 0.0 5.0</P><P><B>&lt;xform_type&gt; options </B></P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">scroll_x</DIV></TD><TD WIDTH="88%" HEIGHT="19"> 
Animate the x scroll value</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">scroll_y</DIV></TD><TD WIDTH="88%" HEIGHT="19">Animate 
the y scroll value</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">rotate</DIV></TD><TD WIDTH="88%" HEIGHT="19">Animate 
the rotate value</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">scale_x</DIV></TD><TD WIDTH="88%" HEIGHT="19">Animate 
the x scale value</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">scale_y</DIV></TD><TD WIDTH="88%" HEIGHT="19">Animate 
the y scale value</TD></TR></TABLE><P><B>&lt;wave_type&gt; options</B></P><TABLE WIDTH="100%" BORDER="1" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">sine</DIV></TD><TD WIDTH="88%" HEIGHT="19"> 
A typical sine wave which smoothly loops between min and max values</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">triangle</DIV></TD><TD WIDTH="88%" HEIGHT="19">An 
angled wave which increases &amp; decreases at constant speed, changing instantly 
at the extremes </TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">square</DIV></TD><TD WIDTH="88%" HEIGHT="19">Max 
for half the wavelength, min for the rest with instant transition between</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">sawtooth</DIV></TD><TD WIDTH="88%" HEIGHT="19">Gradual 
steady increase from min to max over the period with an instant return to min 
at the end.</TD></TR><TR><TD WIDTH="12%" HEIGHT="19"><DIV ALIGN="CENTER">inverse_sawtooth</DIV></TD><TD WIDTH="88%" HEIGHT="19">Gradual 
steady decrease from max to min over the period, with an instant return to max 
at the end. </TD></TR></TABLE><P><B>&lt;base&gt;</B>: The base value, the minimum 
if amplitude &gt; 0, the maximum if amplitdue &lt; 0</P><P><B>&lt;frequency&gt;</B>: 
The number of wave iterations per second, i.e. speed</P><P><B>&lt;phase&gt;</B>: 
Offset of the wave start</P><P><B>&lt;amplitude&gt;</B>: The size of the wave</P><P>The 
range of the output of the wave will be {base, base+amplitude}. So the example 
above scales the texture in the x direction between 1 (normal size) and 5 along 
a sine wave at one cycle every 5 second (0.2 waves per second).</P><TABLE WIDTH="100%" BORDER="0" CELLSPACING="2" CELLPADDING="0"><TR><TD WIDTH="14%"><A HREF="index.html">Back 
to Index</A></TD><TD WIDTH="39%">&nbsp;</TD><TD WIDTH="22%"><A HREF="MaterialScript.html">&lt;&lt; 
Previous section</A></TD><TD WIDTH="25%"><A HREF="ParticleScript.html">Next section 
&gt;&gt;</A></TD></TR></TABLE><P>&nbsp;</P><P>&nbsp;</P><P>&nbsp;</P><P CLASS="SectionHeader">&nbsp;</P>
</body>
</html>
