<html>
<head>
<title>Tutorial: Overlays</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><STYLE TYPE="text/css">
<!--
.MainHeader {  font-weight: bold; color: #FFFF33; background-color: #006600; font-size: 10pt}
body {  font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt; color: #CCFFCC; background-color: #003300}
.BorderHeader {  background-color: #999900; font-size: 8pt; font-weight: bold; color: #333300; text-align: center}
.MainContent { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt; color: #CCFFCC }
.BorderContent {  font-size: 8pt; color: #66CC33; border-color: black #666600 #666600; padding-top: 2px; padding-right: 2px; padding-bottom: 10px; padding-left: 2px; margin-bottom: 2px; border-style: solid; border-top-width: 0px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px}
a:link {  color: #FFFF00; text-decoration: underline}
a:hover {  color: #FFFFFF; text-decoration: underline}
a:visited {  color: #FFCC66; text-decoration: underline}
li {  color: #66CC33; list-style-type: circle; position: relative; left: -15px; clip:    rect(   )}
.NewsDate {  color: #CCFFCC; font-weight: bold}
td {  font-size: 10pt}
th {  font-size: 10pt}
.Annotation {  font-size: 10px}

H1 { text-align: center; }
A.qindex {}
A.qindexRef {}
A.el { text-decoration: none; font-weight: bold }
A.elRef { font-weight: bold }
A.code { text-decoration: none; font-weight: normal; color: #4444ee }
A.codeRef { font-weight: normal; color: #4444ee }
DL.el { margin-left: -1cm }
DIV.fragment { width: 100%; border: none; background-color: #003300 }
DIV.ah { background-color: black; margin-bottom: 3; margin-top: 3 }
TD.md { background-color: #006600 }
DIV.groupHeader { margin-left: 16; margin-top: 12; margin-bottom: 6; font-weight: bold }
DIV.groupText { margin-left: 16; font-style: italic; font-size: smaller }
FONT.keyword       { color: #008000 }
FONT.keywordtype   { color: #999920 }
FONT.keywordflow   { color: #e0FF00 }
FONT.comment       { color: #009900 }
FONT.preprocessor  { color: #809020 }
FONT.stringliteral { color: #002080 }
FONT.charliteral   { color: #008080 }

H3 {
    FONT-FAMILY: trebuchet ms,helvetica,arial
}

.ex {
    FONT-SIZE: 8pt; FONT-FAMILY: tahoma
}
CODE.keywordtype {
    COLOR: #00ccff
}
CODE.keyword {
    FONT-WEIGHT: bold; COLOR: #00ccff
}
CODE.fn {
    COLOR: white;
    FONT-WEIGHT: bold;
}
CODE.var {
    COLOR: #dcdcdc;
}
CODE.macro {
    COLOR: #809020;
    FONT-WEIGHT: bold;
}
CODE.comm {
    COLOR: lime
}
CODE.num {
    COLOR: purple
}
CODE.str {
    COLOR: #ffcc33;
    font-style: italic
}
.SectionHeader {  font-size: 14px; color: #FFFFCC; font-weight: bold}
.header {  font-size: 16px; font-weight: bold; color: #FFFFCC}
-->
</STYLE> 
</head>

<body bgcolor="#FFFFFF" text="#000000">
<p align="center" class="header">OGRE (Object-Oriented Graphics Rendering Engine)</p><p align="center" class="header">Tutorial 
1 - Overview<BR>The Material Object</p><p align="left" class="MainHeader">&nbsp;</p><P ALIGN="LEFT" CLASS="SectionHeader">Overlays</P><P ALIGN="LEFT">Overlays 
allow you to render 2D and 3D elements on top of the normal scene contents to 
create effects like heads-up displays (HUDs), menu systems, status panels etc. 
The frame rate statistics panel which comes as standard with OGRE is an example 
of an overlay.</P><P ALIGN="LEFT">Overlays can contain 2D or 3D elements. 2D elements 
are used for HUDs, and 3D elements can be used to create cockpits or any other 
3D object which you wish to be rendered on top of the rest of the scene.</P><P ALIGN="LEFT">You 
can create overlays either through the SceneManager::createOverlay method, or 
you can define them in an <A HREF="OverlayScript.html">.overlay script</A>. In 
reality the latter is likely to be the most practical because it is easier to 
tweak (without the need to recompile the code). Note that you can define as many 
overlays as you like: they all start off life hidden, and you display them by 
calling their 'show()' method. You can also show multiple overlays at once, and 
their Z order is determined by the Overlay::setZOrder() method.</P><P><SPAN CLASS="SectionHeader">Creating 
2D Elements</SPAN></P><P>The GuiElement class abstracts the details of 2D elements 
which are added to overlays. All items which can be added to overlays are derived 
from this class. It is possible (and encouraged) for users of OGRE to define their 
own custom subclasses of GuiElement in order to provide their own user controls. 
The key common features of all GuiElements are things like size, position, basic 
material name etc. Subclasses extend this behaviour to include more complex properties 
and behaviour.</P><P>An important built-in subclass of GuiElement is GuiContainer. 
GuiContainer is the same as a GuiElement, except that it can contain other GuiElements, 
grouping them together (allowing them to be moved together for example) and providing 
them with a local coordinate origin for easier lineup.</P><P>The third important 
class is GuiManager. Whenever an application wishes to create a 2D element to 
add to an overlay (or a container), it should call GuiManager::createGuiElement. 
The type of element you wish to create is identified by a string, the reason being 
that it allows plugins to register new types of GuiElement for you to create without 
you having to link specifically to those libraries. For example, to create a panel 
(a plain rectangular area which can contain other GuiElements) you would call 
GuiManager::getSingleton().createGuiElement(&quot;Panel&quot;, &quot;myNewPanel&quot;);</P><P CLASS="SectionHeader">Adding 
2D Elements to the Overlay</P><P>Only GuiContainers can be added direct to an 
overlay. The reason is that each level of container establishes the Zorder of 
the elements contained within it, so if you nest several containers, inner containers 
have a higher zorder than outer ones to ensure they are displayed correctly.</P><P>To 
add a container (such as a Panel) to the overlay, simply call Overlay::add2D.</P><P>If 
you wish to add child elements to that container, call GuiContainer::addChild. 
Child elements can be GuiElements or GuiContainer instances themselves. Remember 
that the position of a child element is relative to the top-left corner of it's 
parent.</P><P CLASS="SectionHeader">A word about 2D coordinates</P><P>Because 
OGRE can run at any resolution, using pixels as coordinates to place 2D elements 
is not practical. Instead, OGRE uses a relative coordinate system; the top-left 
of the screen is (0,0) and the bottom-right is (1,1). So if you place an element 
at (0.5, 0,5), it's top-left corner is placed exactly in the center of the screen, 
no matter what resolution the application is running in.</P><P>The same principle 
applies to sizes; if you set the width of an element to 0.5, it covers half the 
width of the screen. Note that because the aspect ratio of the screen is typically 
1.3333 : 1 (width : height), an element with dimensions (0.25, 0.25) will not 
be square, but it will take up exactly 1/16th of the screen in area terms. If 
you want square-looking areas you will have to compensate using the typical aspect 
ratio eg use (0.1875, 0.25) instead.</P><P CLASS="SectionHeader">Transforming 
Overlays</P><P>Another nice feature of overlays is being able to rotate, scroll 
and scale them as a whole. You can use this for zooming in / out menu systems, 
dropping them in from off screen and other nice effects. See the Overlay::scroll, 
Overlay::rotate and Overlay::scale methods for more information.</P><TABLE WIDTH="100%" BORDER="0" CELLSPACING="2" CELLPADDING="0"><TR><TD WIDTH="14%"><A HREF="../index.html">Back 
to Index</A></TD><TD WIDTH="39%">&nbsp;</TD><TD WIDTH="22%"><A HREF="entity.html">&lt;&lt; 
Previous section</A></TD><TD WIDTH="25%"><A HREF="OverlayScript.html">Next section 
&gt;&gt;</A></TD></TR></TABLE><P>&nbsp;</P><P>&nbsp;</P><P>&nbsp;</P><P CLASS="SectionHeader">&nbsp;</P>
</body>
</html>
