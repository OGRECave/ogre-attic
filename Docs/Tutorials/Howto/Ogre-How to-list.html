<!DOCTYPE html PUBLIC "-//w3c//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>The Ogre-engine: how to-list</title></head>


  
  <body>

    <h2>How to-list</h2>

    <p>Written by Oogst, last update on 25-05-2004, check <a href="http://home.hccnet.nl/w.vdongen/Oogst/Index.html">the Oogst-site</a> for more Oogst-stuff.</p>

    <h3>About this list</h3>

    <p>This
is a list of how to do simple things in Ogre. It contains mainly simple
code examples, which is something I myself really missed while learning
the basics of Ogre. The explanations provided here are all kept brief.
For more details on all the things mentioned, see:<br>
    -the official manual for the Ogre-basics and the script-definitions;<br>
    -the API for descriptions of all classes and functions in Ogre;<br>
    -the tutorials provided with Ogre;<br>
    -the search-function of the Ogre-forum.</p>

    <h3>Why I made this list</h3>

    <p>I made this list for four reasons:<br>
    -I am working on a group project at school and the rest of the team would like to be able to find code examples quickly;<br>
    -I really missed this kind of thing when learning Ogre myself and it would have saved me a lot of time;<br>
    -I keep forgetting function-names and this way I can look them up quickly;<br>
-I wanted to do something in return for the fantastic engine the
Ogre-team has provided and which I can use for free without any
expectation from the creators of getting something back for it.</p>

    <h3>ExampleApplication</h3>

    <p>This
list works from the ExampleApplication and supposes the user uses
ExampleApplication and ExampleFrameListener. Some variables, like
mSceneMgr, are only available with this name through
ExampleApplication. If you are not using ExampleApplication, you will
have to fill in the different variables yourself.</p>

    <p>Furthermore,
all examples use arbitrary names for variables and such; of course you
should change these to what you find appropriate for your own
application.</p>

    <h3>How to...</h3>

    <p><a href="#setup">...set up an application using ExampleApplication</a><br>
    <a href="#model">...put a 3D-model in the scene</a><br>
    <a href="#remove">...remove a 3D-model from the scene</a><br>
    <a href="#node">...move, reposition, scale and rotate a SceneNode</a><br>
    <a href="#light">...put a light in the scene</a><br>
    <a href="#ambient">...set the ambient lighting</a><br>
    <a href="#camera">...control the camera</a><br>
    <a href="#billboard">...add a billboard/sprite to the scene</a><br>
    <a href="#framelistener">...create a basic FrameListener using ExampleFrameListener</a><br>
    <a href="#control">...control some object from your scene in a FrameListener</a><br>
    <a href="#time">...get the time since the previous frame</a><br>
    <a href="#keys">...react to key-presses</a><br>
    <a href="#timer">...make sure key-presses are not reacted to too shortly after each other</a><br>
    <a href="#quit">...quit you application</a><br>
    <a href="#add">...efficiently add and remove 3D-objects from the scene during run-time (like rockets being fired)</a><br>
    <a href="#overlay">...show an Overlay (and hide it again)</a><br>
    <a href="#textarea">...change the text in a TextArea</a><br>
    <a href="#cursor">...show the mouse-cursor</a><br>
    <a href="#button">...create a working button</a><br>
    <a href="#whichbutton">...find out which button was pressed</a><br>
    <a href="#quitaction">...quit the application using an ActionListener</a><br>
    <a href="#scenemanager">...get a different SceneManager</a><br>
    <a href="#collision">...efficiently get a list of all possible collisions</a><br>
    <a href="#movableobject">...find out to which of your own objects a MovableObject belongs</a><br>
    <a href="#exclude">...exclude objects from collision detection</a></p>

    <a name="setup"></a><h3><a name="setup">...set up an application using ExampleApplication</a></h3>

<a name="setup">    </a><p><a name="setup">If you do not know how this
works already, you MUST read more about it in Ogre&#8217;s tutorial-section:
it is really important to understand this properly. In short it
requires creating a class that is derived from ExampleApplication. This
class can implement the functions createScene() and
createFrameListener(). It will probably look something like this:</a></p>

<a name="setup">    </a><p></p><pre><a name="setup">    #include "ExampleApplication.h"

    class MyClass: public ExampleApplication,
    {
    public:
      MyClass(void);
      ~MyClass(void);
    protected:
      void createScene(void);
      void createFrameListener(void);
    };</a></pre>

<a name="setup">    </a><p><a name="setup">You will also need a
.cpp-file that creates one instance of MyClass and runs it. In general
it will look something like this (taken from the &#8220;Guide To Setting Up
Application Project Files&#8221;-tutorial):</a></p>

<a name="setup">    </a><p></p><pre><a name="setup">    #include "Ogre.h"
    #include "MyClass.h"

    #if OGRE_PLATFORM == PLATFORM_WIN32
    #define WIN32_LEAN_AND_MEAN
    #include "windows.h"

    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
    #else
    int main(int argc, char **argv)
    #endif
    {
      MyClass app;

      try
      {
        app.go();
      }
      catch( Exception&amp; e )
      {
    #if OGRE_PLATFORM == PLATFORM_WIN32
        MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
    #else
        fprintf(stderr, "An exception has occured: %s\n", e.getFullDescription().c_str());
    #endif
      }
      return 0;
    }</a></pre>


<a name="setup">    </a><a name="model"></a><h3><a name="model">...put a 3D-model in the scene</a></h3>

<a name="model">    </a><p><a name="model">A 3D-model is an Entity and
it must be attached to a SceneNode to be placed in the scene. The
SceneNode can be taken from the rootSceneNode in the SceneManager.
Creating an Entity and SceneNode and attaching the Entity to the
SceneNode will look something like this:</a></p>

<a name="model">    </a><p></p><pre><a name="model">    Entity* thisEntity = mSceneMgr-&gt;createEntity("nameInTheScene", "FileName.mesh");
    SceneNode* thisSceneNode = static_cast&lt;SceneNode*&gt;(mSceneMgr-&gt;getRootSceneNode()-&gt;createChild());
    thisSceneNode-&gt;attachObject(thisEntity);</a></pre>


<a name="model">    </a><a name="remove"></a><h3><a name="remove">...remove a 3D-model from the scene</a></h3>

<a name="remove">    </a><p><a name="remove">To remove a 3D-model, you
must detach the Entity from its SceneNode, delete it and if needed
destroy the SceneNode as well, which must be done using the
SceneManager. If you have a SceneNode* called myNode you can completely
destroy all its contents (both MovableObjects and child SceneNodes) and
the node itself using the following code:</a></p>

<a name="remove">    </a><p></p><pre><a name="remove">    while(myNode-&gt;numAttachedObjects() &gt; 0)

    {
      MovableObject* thisObject = myNode-&gt;detachObject(static_cast&lt;unsigned short&gt;(0));
      delete thisObject;
    }
    myNode-&gt;removeAndDestroyAllChildren();
    mSceneMgr-&gt;getRootSceneNode()-&gt;removeAndDestroyChild(myNode-&gt;getName());</a></pre>


<a name="remove">    </a><a name="node"></a><h3><a name="node">...move, reposition, scale and rotate a SceneNode</a></h3>

<a name="node">    </a><p><a name="node">If you have a SceneNode with
some MovableObjects, like Entities, Lights and Cameras, attached to it,
you can move it using a lot of different functions, see the API for all
of them. The following functions respectively move it, reposition it,
scale it and rotate it over its X-, Y- and Z-axis:</a></p>

<a name="node">    </a><p></p><pre><a name="node">    thisSceneNode-&gt;translate(10, 20, 30);
    thisSceneNode-&gt;setPosition(1.8, 20.1, 10.5);
    thisSceneNode-&gt;scale(0.5, 0.8, 1.3);
    thisSceneNode-&gt;pitch(45);
    thisSceneNode-&gt;yaw(90);</a></pre>
<a name="node">    thisSceneNode-&gt;roll(180);


    </a><a name="light"></a><h3><a name="light">...put a light in the scene</a></h3>

<a name="light">    </a><p><a name="light">To add a light to the scene,
you must ask the SceneManager for one. You can then set its settings,
of which some examples are given below:</a></p>

<a name="light">    </a><p></p><pre><a name="light">    Light* myLight = mSceneMgr-&gt;createLight("nameOfTheLight");
    myLight-&gt;setType(Light::LT_POINT);
    myLight-&gt;setPosition(200, 300, 400);
    myLight-&gt;setDiffuseColour(1, 1, 0.7);
    myLight-&gt;setSpecularColour(1, 1, 0.7);</a></pre>

<a name="light">    </a><p><a name="light">You can also attach a light to a SceneNode. The following code creates a SceneNode and attaches myLight to it:</a></p>

<a name="light">    </a><p></p><pre><a name="light">    SceneNode* thisSceneNode = static_cast&lt;SceneNode*&gt;(mSceneMgr-&gt;getRootSceneNode()-&gt;createChild());
    thisSceneNode-&gt;attachObject(myLight);</a></pre>


<a name="light">    </a><a name="ambient"></a><h3><a name="ambient">...set the ambient lighting</a></h3>

<a name="ambient">    </a><p><a name="ambient">The ambient lighting is controlled by the Scenemanager, so that is where you can set it:</a></p>

<a name="ambient">    </a><p></p><pre><a name="ambient">    mSceneMgr-&gt;setAmbientLight(ColourValue(0.2, 0.2, 0.2));</a></pre>


<a name="ambient">    </a><a name="camera"></a><h3><a name="camera">...control the camera</a></h3>

<a name="camera">    </a><p><a name="camera">The standard camera in
ExampleApplication is called mCamera and is available in the class that
is derived from ExampleApplication. The following code changes its
position, changes the point it looks at, creates a SceneNode and
attaches the camera to it:</a></p>

<a name="camera">    </a><p></p><pre><a name="camera">    mCamera-&gt;setPosition(0, 130, -400);
    mCamera-&gt;lookAt(0, 40, 0);
    SceneNode* thisSceneNode = static_cast&lt;SceneNode*&gt;(mSceneMgr-&gt;getRootSceneNode()-&gt;createChild());
    thisSceneNode-&gt;attachObject(mCamera);</a></pre>


<a name="camera">    </a><a name="billboard"></a><h3><a name="billboard">...add a billboard/sprite to the scene</a></h3>

<a name="billboard">    </a><p><a name="billboard">A Billboard is a
square polygon that is always pointed at the camera. It is also known
as a sprite. To make one, you must first make a BillboardSet. Then the
billboard can be added to it on a given position. The BillboardSet is a
MovableObject en should therefore be added to a SceneNode. The whole
procedure is as follows:</a></p>

<a name="billboard">    </a><p></p><pre><a name="billboard">    SceneNode* myNode = static_cast<scenenode *="">(mSceneMgr-&gt;getRootSceneNode()-&gt;createChild());
    BillboardSet* mySet = mSceneMgr-&gt;createBillboardSet("mySet");
    Billboard* myBillboard = mySet-&gt;createBillboard(Vector3(100, 0, 200));
    myNode-&gt;attachObject(mySet);</scenenode></a></pre>


<a name="billboard">    </a><a name="framelistener"></a><h3><a name="framelistener">...create a basic FrameListener using ExampleFrameListener</a></h3>

<a name="framelistener">    </a><p><a name="framelistener">A
FrameListener gives you the opportunity to do something at the start
and the end of every frame. You must first create a class that is
derived from ExampleFrameListener and in this class you can implement
frameStarted() and frameEnded(). This will look something like this:</a></p>

<a name="framelistener">    </a><p></p><pre><a name="framelistener">    #include "ExampleFrameListener.h"

    class myFrameListener: public ExampleFrameListener
    {
    public:
      myFrameListener(RenderWindow* win, Camera* cam);
      ~myFrameListener(void);
      bool frameStarted(const FrameEvent&amp; evt);
      bool frameEnded(const FrameEvent&amp; evt);
    };</a></pre>

<a name="framelistener">    </a><p><a name="framelistener">The constructor should call its parent-constructor, which will look something like this:</a></p>

<a name="framelistener">    </a><p></p><pre><a name="framelistener">    myFrameListener::myFrameListener(RenderWindow* win, Camera* cam): ExampleFrameListener(win, cam){}</a></pre>

<a name="framelistener">    </a><p><a name="framelistener">You must
also register your FrameListener to the Root. This can be done in the
createFrameListener()-function of the class that is derived from
ExampleApplication. You can register as many FrameListeners to the root
as you want. It will look something like this:</a></p>

<a name="framelistener">    </a><p></p><pre><a name="framelistener">    void createFrameListener(void)
    {
      MyFrameListener listener = new MyFrameListener(mWindow, mCamera);
      mRoot-&gt;addFrameListener(listener);
    }</a></pre>


<a name="framelistener">    </a><a name="control"></a><h3><a name="control">...control some object from your scene in a FrameListener</a></h3>

<a name="control">    </a><p><a name="control">If you want to control
some object you have in your scene in a FrameListener, the
FrameListener must have access to it. An easy way to do this, is by
providing a pointer to it in the constructor of the FrameListener. Its
constructor will now look something like this:</a></p>

<a name="control">    </a><p></p><pre><a name="control">    myFrameListener(RenderWindow* win, Camera* cam, Car* car);</a></pre>


<a name="control">    </a><a name="time"></a><h3><a name="time">...get the time since the previous frame</a></h3>

<a name="time">    </a><p><a name="time">In the functions frameEnded()
and frameStarted() of a FrameListener you can get the time in seconds
(this is a float) in the following way:</a></p>

<a name="time">    </a><p></p><pre><a name="time">    bool frameStarted(const FrameEvent&amp; evt)
    {
      float time = evt.timeSinceLastFrame;
      return true;
    }</a></pre>

<a name="time">    </a><p><a name="time">You can now for instance
multiply the speed per second with this float in order to get the
movement since the last frame. This will make the pace of the game
framerate-independent.</a></p>


<a name="time">    </a><a name="keys"></a><h3><a name="keys">...react to key-presses</a></h3>

<a name="keys">    </a><p><a name="keys">In the functions frameEnded()
and frameStarted() of a FrameListener you can react to key-presses by
first ordering Ogre to capture them and then checking which key is
being pressed. You only have to capture the InputDevice once per frame.
This will look something like this:</a></p>

<a name="keys">    </a><p></p><pre><a name="keys">    mInputDevice-&gt;capture();
    if (mInputDevice-&gt;isKeyDown(Ogre::KC_DOWN))
    {
      //react however you like
    }
    if (mInputDevice-&gt;isKeyDown(Ogre::KC_UP))
    {
      //react however you like
    }</a></pre>


<a name="keys">    </a><a name="timer"></a><h3><a name="timer">...make sure key-presses are not reacted to too shortly after each other</a></h3>

<a name="timer">    </a><p><a name="timer">If you implement reactions
to key-presses in the above way, they will happen each frame. If you
want them to happen, for instance, at most twice per second, you can
achieve this by setting a timer. This timer must be kept in the class
itself and not in the function in order to be able to access it through
different calls of the function. Implementing this will look something
like this:</a></p>

<a name="timer">    </a><p></p><pre><a name="timer">    class myFrameListener: public ExampleFrameListener
    {
    protected:
      float buttonTimer;
    public:
      myFrameListener(RenderWindow* win, Camera* cam): ExampleFrameListener(win, cam)
      {
        buttonTimer = 0;
      }	
      bool frameStarted(const FrameEvent&amp; evt)
      {
        float time = evt.timeSinceLastFrame;
        buttonTimer -= time;
        mInputDevice-&gt;capture();
        if (mInputDevice-&gt;isKeyDown(Ogre::KC_DOWN) &amp;&amp; buttonTimer &lt;= 0)
        {
          buttonTimer = 0.5;
          //react however you like
        }
        return true;
      }
    };</a></pre>


<a name="timer">    </a><a name="quit"></a><h3><a name="quit">...quit you application</a></h3>

<a name="quit">    </a><p><a name="quit">You can quit you application
in the frameStarted() or frameEnded()-function of the FrameListener by
returning false. If you want to tie this to pressing the escape-button
on the keyboard, this will look as follows:</a></p>

<a name="quit">    </a><p></p><pre><a name="quit">    bool frameStarted(const FrameEvent&amp; evt)
    {
      mInputDevice-&gt;capture();
      if (mInputDevice-&gt;isKeyDown(Ogre::KC_ESCAPE))
        return false;
      return true;
    }</a></pre>


<a name="quit">    </a><a name="add"></a><h3><a name="add">...efficiently add and remove 3D-objects from the scene during run-time (like rockets being fired)</a></h3>

<a name="add">    </a><p><a name="add">In the createScene()-function
you can load meshes from a file, but this is too slow to do if new
objects must be added in run-time (though in a very simple application
you will not see the difference in speed). To add objects faster, you
can load a lot of meshes in the createScene()-function and then take
them from a stack in run-time. After the objects are not used anymore,
you can put them back on the stack for later use. A good example of the
usefulness of this is a canon that fires rockets: these must be created
when fired and removed when exploded.</a></p>

<a name="add">    </a><p><a name="add">In order to always have access
to this stack of rockets, you can make it a global variable (outside
any class) or access it through a singleton. The latter is much nicer,
but takes more code so I will not do so in this example. So you keep a
stack of Entities somewhere:</a></p>

<a name="add">    </a><p></p><pre><a name="add">    stack<entity *=""> rocketEntities;</entity></a></pre>

<a name="add">    </a><p><a name="add">In createScene() you fill this
stack with a lot of rockets. Each Entity is set invisible for now and
must have a unique name, which is achieved using the
sprintf()-function. All in all it looks like this:</a></p>

<a name="add">    </a><p></p><pre><a name="add">    for (unsigned int t = 0; t &lt; 100; t++)
    {
      char tmp[20];
      sprintf(tmp, "rocket_%d", t);
      Entity* newRocketEntity = mSceneMgr-&gt;createEntity(tmp, "Rocket.mesh");
      newRocketEntity-&gt;setVisible(false);
      rocketEntities.push(newRocketEntity);
    }</a></pre>

<a name="add">    </a><p><a name="add">Now when creating a new Rocket
we can take a mesh from rocketEntities. In this example I do so in the
constructor of the Rocket and put it pack in the destructor of the
Rocket. In order to get the Entity back from the SceneNode in the
destructor, I store its name in rocketEntityName. I also position the
rocket correctly in the constructor. To make this all work, the
SceneManager must be available throughout your program, in this case
this is achieved by having it be a global variable (outside any class).
I also handle creation and destruction of the SceneNode in the
constructor and destructor. The Rocket-class will now look like this:</a></p>

<a name="add">    </a><p></p><pre><a name="add">    class Rocket
    {
    protected:
      SceneNode* rocketNode;
      string rocketEntityName;
    public:
      Rocket(const Vector3&amp; position, const Quaternion&amp; direction)
      {
        rocketNode = static_cast&lt;SceneNode*&gt;(sceneMgr-&gt;getRootSceneNode()-&gt;createChild());
        Entity* rocketEntity = rocketEntities.top();
        rocketEntities.pop();
        rocketEntity-&gt;setVisible(true);
        rocketEntityName = rocketEntity-&gt;getName();
        rocketNode-&gt;attachObject(rocketEntity);
        rocketNode-&gt;setOrientation(direction);
        rocketNode-&gt;setPosition(position);
      }
      ~Rocket()
      {
        Entity* rocketEntity = static_cast&lt;Entity*&gt;(rocketNode-&gt;detachObject(rocketEntityName));
        rocketEntity-&gt;setVisible(false);
        rocketEntities.push(rocketEntity);
        sceneMgr-&gt;getRootSceneNode()-&gt;removeAndDestroyChild(rocketNode-&gt;getName());
      }
    };</a></pre>

<a name="add">    </a><p><a name="add">If you use this construction,
you should be aware of the fact that this crashes if no rockets are
left. You can solve this by checking whether the stack of Entities is
empty and if it is, load new meshes to add to the stack.</a></p>


<a name="add">    </a><a name="overlay"></a><h3><a name="overlay">...show an Overlay (and hide it again)</a></h3>

<a name="overlay">    </a><p><a name="overlay">To show and hide an
Overlay, you must first get a pointer to it using the OverlayManager,
which is a singleton. If you have an Overlay that is defined in a
.overlay-script with the name &#8220;myOverlay&#8221; you can get it, show it and
hide it again using the following code:</a></p>

<a name="overlay">    </a><p></p><pre><a name="overlay">    Overlay* thisOverlay = static_cast&lt;Overlay*&gt;(OverlayManager::getSingleton().getByName("myOverlay"));
    thisOverlay-&gt;show();
    thisOverlay-&gt;hide();</a></pre>

<a name="overlay">    </a><a name="textarea"></a><h3><a name="textarea">...change the text in a TextArea</a></h3>

<a name="textarea">    </a><p><a name="textarea">You can change all
parameters of Containers and Elements in the GUI in runtime. In order
to do so, you must first get a pointer to the Element or Container you
want and, if needed for what you want to do, cast it to the type it is.
Getting a pointer to a TextArea that is defined in a .overlay-script as
&#8220;myTextArea&#8221; and changing its caption will look something like this:</a></p>

<a name="textarea">    </a><p></p><pre><a name="textarea">    GuiElement* thisTextArea = GuiManager::getSingleton().getGuiElement("myTextArea");
    thisTextArea-&gt;setCaption(&#8220;blaat&#8221;);</a></pre>

<a name="textarea">    </a><p><a name="textarea">In this case no
casting was needed, as every GuiElement has a caption. If you want to
set a setting that is specific for one type of GuiElement, you will
have to cast it to that type. Changing the font-name of a TextArea will
look something like this:</a></p>

<a name="textarea">    </a><p></p><pre><a name="textarea">    TextAreaGuiElement* thisTextArea = static_cast&lt;TextAreaGuiElement*&gt;(GuiManager::getSingleton().getGuiElement("myTextArea"));
    thisTextArea-&gt;setFontName(&#8220;RealCoolFont&#8221;);</a></pre>


<a name="textarea">    </a><a name="cursor"></a><h3><a name="cursor">...show the mouse-cursor</a></h3>

<a name="cursor">    </a><p><a name="cursor">If you want to show the
mouse-cursor on the screen, you have to do two things: set it to be
shown and tell a FrameListener to track it. Telling it to be shown can
be done as follows:</a></p>

<a name="cursor">    </a><p></p><pre><a name="cursor">    GuiContainer* cursor = OverlayManager::getSingleton().getCursorGui();
    cursor-&gt;setMaterialName("Cursor/default");
    cursor-&gt;setDimensions(32.0/640.0, 32.0/480.0);
    cursor-&gt;show();</a></pre>

<a name="cursor">    </a><p><a name="cursor">Telling a FrameListener to
track it should be done in its parents&#8217; constructor by setting its last
boolean-parameter to true. The constructor will now look something like
this:</a></p>

<a name="cursor">    </a><p></p><pre><a name="cursor">    myFrameListener::myFrameListener(RenderWindow* win, Camera* cam): ExampleFrameListener(win, cam, false, true){}</a></pre>

<a name="cursor">    </a><p><a name="cursor">Beware though that after
doing this, this specific FrameListener will not react to
button-presses anymore as the capture()- and isKeyPressed()-functions
of mInputDevice now do not work properly anymore. A different
FrameListener should be made to handle keyboard input now.</a></p>


<a name="cursor">    </a><a name="button"></a><h3><a name="button">...create a working button</a></h3>

<a name="button">    </a><p><a name="button">You can define a button in
an Overlay-script using something like the following syntax, where it
is important to set all these materials:</a></p>

<a name="button">    </a><p></p><pre><a name="button">    container Button(myButton)
    {
      metrics_mode relative
      horz_align left
      vert_align top
      top 0.1
      left 0.1
      width 0.18
      height 0.1
      material NCG/GuiSession/RedMaterial
      button_down_material NCG/GuiSession/RedMaterial
      button_up_material NCG/GuiSession/RedMaterial
      button_hilite_down_material NCG/GuiSession/RedMaterial
      button_hilite_up_material NCG/GuiSession/RedMaterial
      button_disabled_material NCG/GuiSession/RedMaterial
    }</a></pre>

<a name="button">    </a><p><a name="button">Buttons are not standard
in Ogre and therefore you must make sure they are found by the compiler
in the folder ogrenew\PlugIns\GuiElements\Include. Now you can include
it:</a></p>

<a name="button">    </a><p></p><pre><a name="button">    #include &#8220;OgreButtonGuiElement.h&#8221;</a></pre>

<a name="button">    </a><p><a name="button">To make the button work, an ActionListener must be registered to it, which can be done as follows:</a></p>

<a name="button">    </a><p></p><pre><a name="button">    ActionTarget* thisButton = static_cast&lt;ButtonGuiElement*&gt;(GuiManager::getSingleton().getGuiElement("myButton"));
    thisButton-&gt;addActionListener(this);</a></pre>

<a name="button">    </a><p><a name="button">This examples supposes
&#8216;this&#8217; is an ActionListener, which is not true by default. Of cource
any ActionListener will do, it does not have to be &#8216;this&#8217;. You can make
a class an ActionListener by deriving it from ActionListener and
implementing actionPerformed(). This will look something like this:</a></p>

<a name="button">    </a><p></p><pre><a name="button">    
    class Listener: public ActionListener
    {
    public:
      void actionPerformed(ActionEvent *e);
    };</a></pre>


<a name="button">    </a><a name="whichbutton"></a><h3><a name="whichbutton">...find out which button was pressed</a></h3>

<a name="whichbutton">    </a><p><a name="whichbutton">If you register
one ActionListener to several buttons, they will all call the same
function actionPerformed(). You can find out which button was actually
being pressed by comparing its name with the name in the ActionEvent e.
This will look something like this:</a></p>

<a name="whichbutton">    </a><p></p><pre><a name="whichbutton">    #include <string>

    void actionPerformed(ActionEvent *e)
    {
      std::string action = e-&gt;getActionCommand();
      if (action == "myButton")
      {
        //handle the button-press
      }
    }</string></a></pre>


<a name="whichbutton">    </a><a name="quitaction"></a><h3><a name="quitaction">...quit the application using an ActionListener</a></h3>

<a name="quitaction">    </a><p><a name="quitaction">Quiting an
application can be done in the frameStarted()- and
frameEnded()-functions of a FrameListener, not in the
actionPerformed()-function. So how do we get there? For this we can
introduce a simple FrameListener that does nothing more than quit if
asked to. This FrameListener will look something like this (from the
Gui-demo provided with Ogre):</a></p>

<a name="quitaction">    </a><p></p><pre><a name="quitaction">    #include &#8220;ExampleFrameListener.h&#8221;

    class QuitListener: public ExampleFrameListener
    {
    public:
      QuitListener(RenderWindow* win, Camera* cam): ExampleFrameListener(win, cam, false, false)
      {
        quit = false;
      }
      bool frameStarted(const FrameEvent&amp; evt)
      {
        if (quit)
          return false;
        return true;
      }
      void scheduleQuit(void)
      {
      quit = true;
      }
    protected:
      bool quit;
    };</a></pre>

<a name="quitaction">    </a><p><a name="quitaction">Now if your
ActionListener has a pointer to this QuitListener, it can simply
schedule a quit by calling scheduleQuit() and the QuitListener will
perform it before the next frame starts.</a></p>


<a name="quitaction">    </a><a name="scenemanager"></a><h3><a name="scenemanager">...get a different SceneManager</a></h3>

<a name="scenemanager">    </a><p><a name="scenemanager">The
SceneManager is chosen automatically using an identifier that tells
what kind of scene it is. This is done in ExampleApplication, so to
change this, you will have to change ExampleApplication itself.
Normally, ExampleApplication contains the following piece of code:</a></p>

<a name="scenemanager">    </a><p></p><pre><a name="scenemanager">    virtual void chooseSceneManager(void)
    {
      // Get the SceneManager, in this case a generic one
      mSceneMgr = mRoot-&gt;getSceneManager(ST_GENERIC);
    }</a></pre>

<a name="scenemanager">    </a><p><a name="scenemanager">You can change ST_GENERIC to any of the following identifiers to get a SceneManager that is appropriate for your specific scene:
    ST_GENERIC
    ST_EXTERIOR_CLOSE
    ST_EXTERIOR_FAR
    ST_EXTERIOR_REAL_FAR
    ST_INTERIOR</a></p>


<a name="scenemanager">    </a><a name="collision"></a><h3><a name="collision">...efficiently get a list of all possible collisions</a></h3>

<a name="collision">    </a><p><a name="collision">Ogre can provide you
with a list of all objects that are possible colliding. Objects that
are close but not in a collision might be in this list as well, so you
will have to make sure which one is a collision yourself afterwards.
You can ask for this list of collisions using an
IntersectionSceneQuery, which you can get using the following code:</a></p>

<a name="collision">    </a><p></p><pre><a name="collision">    IntersectionSceneQuery* intersectionQuery = sceneMgr-&gt;createIntersectionQuery();</a></pre>

<a name="collision">    </a><p><a name="collision">Now you can ask it for a list of all possible collisions:</a></p>

<a name="collision">    </a><p></p><pre><a name="collision">    IntersectionSceneQueryResult&amp; queryResult = intersectionQuery-&gt;execute();</a></pre>

<a name="collision">    </a><p><a name="collision">If you intend to get
this list several times before updating your scene, there is no need to
have Ogre calculate it again over and over. You can get back the same
list again without a new calculation using the following line:</a></p>

<a name="collision">    </a><p></p><pre><a name="collision">    IntersectionSceneQueryResult&amp; queryResult = intersectionQuery-&gt;getLastResults();</a></pre>

<a name="collision">    </a><p><a name="collision">After use, you can
store the IntersectionSceneQuery for later use or remove it. If you
remove it, you must tell the SceneManager to do so using the following
code:</a></p>

<a name="collision">    </a><p></p><pre><a name="collision">    mSceneMgr-&gt;destroyQuery(intersectionQuery);</a></pre>

<a name="collision">    </a><p><a name="collision">The
IntersectionSceneQueryResult is a list of pairs of MovableObjects. An
example of its use is getting the name of the first of the two
colliding objects:</a></p>

<a name="collision">    </a><p></p><pre><a name="collision">    queryResult.movables2movables.begin()-&gt;first-&gt;getName();</a></pre>

<a name="collision">    </a><p><a name="collision">See the Ogre-API for more details on the types of the results.</a></p>


<a name="collision">    </a><a name="movableobject"></a><h3><a name="movableobject">...find out to which of your own objects a MovableObject belongs</a></h3>

<a name="movableobject">    </a><p><a name="movableobject">The list of
colliding objects IntersectionSceneQuery delivers is of MovableObjects,
but in general you will want to relate this to some custom object in
your own scene. To do so, you can attach a pointer to your own object
to a MovableObject and get this pointer back later on. If you have an
Entity (which is a MovableObject) and a custom object (like myRocket
here below), you can attach your custom object to the Entity as follows:</a></p>

<a name="movableobject">    </a><p></p><pre><a name="movableobject">    Entity* myEntity = sceneMgr-&gt;createEntity("myEntity&#8221;, "Rocket.mesh");
    Rocket* myRocket = new Rocket();
    myEntity-&gt;setUserObject(myRocket);</a></pre>

<a name="movableobject">    </a><p><a name="movableobject">Now you can get a pointer to myRocket back from the Entity using the following code:</a></p>

<a name="movableobject">    </a><p></p><pre><a name="movableobject">    myEntity-&gt;getUserobject();</a></pre>

<a name="movableobject">    </a><p><a name="movableobject">To make this
work, your own custom class must be derived from UserDefinedObject.
This also allows you to find out what kind of class the returned object
is, so that you can cast it back. The definition for Rocket could now
look something like this:</a></p>

<a name="movableobject">    </a><p></p><pre><a name="movableobject">    class Rocket: public UserDefinedObject
    {
    public:
      const string&amp; getTypeName(void)
      {
        const string&amp; typeName = "Rocket";
        return typeName;
      }
    };</a></pre>

<a name="movableobject">    </a><p><a name="movableobject">Now after
having detected which MovableObjects are involved in a collision, you
can also find out which of your own objects are involved in this
collision.</a></p>


<a name="movableobject">    </a><a name="exclude"></a><h3><a name="exclude">...exclude objects from collision detection</a></h3>

<a name="exclude">    </a><p><a name="exclude">You can exclude certain
objects from collision detection by using flags. You can add a flag to
any MovableObject, for instance 100 in the following example:</a></p>

<a name="exclude">    </a><p></p><pre><a name="exclude">    Entity* ground = mSceneMgr-&gt;createEntity("ground", "Ground.mesh");
    ground-&gt;setQueryFlags(100);</a></pre>

<a name="exclude">    </a><p><a name="exclude">Now you can tell your
IntersectionSceneQuery to exclude objects with this flag from its list
of intersections by setting its mask. This will look like this:</a></p>

<a name="exclude">    </a><p></p><pre><a name="exclude">    IntersectionSceneQuery* intersectionQuery = sceneMgr-&gt;createIntersectionQuery();
    intersectionQuery-&gt;setQueryMask(~100);</a></pre>

<a name="exclude">  </a></body></html>