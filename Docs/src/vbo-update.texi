\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename vbo-update.info
@settitle Hardware Buffers In OGRE
@c %**end of header
   
@titlepage
@title Geometry Changes In OGRE 0.12
@author Steve Streeting
@page
@vskip 0pt plus 1filll
Copyright @copyright{} The OGRE Team@*

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified
versions of this manual under the conditions for verbatim
copying, provided that the entire resulting derived work is
distributed under the terms of a permission notice
identical to this one.
@end titlepage

@node Top
@top Geometry Changes In OGRE 0.12
This manual covers the changes which have been made in the core geometry 
and rendering operation classes in OGRE v0.12.

@ifinfo
@menu
* Introduction::                What's all this about anyway?
* Hardware Buffers::				All about hardware buffers
* Hardware Vertex Buffers::     The stuff that vertices are made of
* Hardware Index Buffers::      Indirect rendering through indexes

@detailmenu
@end detailmenu
@end menu
@end ifinfo


@node Introduction
@chapter Introduction

@section The way it used to be, and why we had to change
Geometry handling, for obvious reasons, is at the centre of any 3D engine.
OGRE inherited much of its core geometry structures from a previous engine I 
designed for DirectX 6 / OpenGL, and it has worked quite well. It was based
around the historical premise that applications wanted to construct a lot
of geometry in main memory, manipulate it on the CPU, and upload it in small
chunks for the hardware to process every frame. This was fine because the card
couldn't handle enormous amounts of polys anyway, so it was up to the application to pick the most appropriate subset to upload. 
@*@*
Times changed, however, with graphics processors beginning to have more and more of their own memory, and being able to process the transformation and lighting on the card itself, or in AGP memory, rather than main memory. This made it feasible to upload static geometry to the card and keep it there, avoiding the bandwidth requirements of the per-frame upload. The advent of vertex shaders has allowed programs to process the vertices in custom ways without having to shuffle them between main memory and the card. We'll call these GPU and AGP-based buffers 'Hardware Buffers'. We often refer to them as 'VBOs' (Vertex Buffer Objects) for speed, although the term is not exactly accurate since they can hold both vertex and index data. The use of hardware buffers can significantly improve the rendering speed of a scene, especially one with a large amount of repeating geometry or one which uses lots of multipass effects.

@*@*
So why did we wait until now? After all, the APIs have supported hardware buffers in some shape or form for some time. Well, there were a few reasons. Firstly, it's a large and disruptive change (to do it properly and use it to it's full) so we had to find time in our schedule. We worked on a separate CVS branch to avoid disturbing regular developers for some time. Secondly, it's actually only in the past 6-12 months that both APIs have exposed these functions in such a way that makes them practical to implement in a generic engine like OGRE. Whilst DirectX has had VBOs since D3D7, version 7 was so simplistic as to be almost useless, and version 8 has a serious design flaw which tied a buffer to a single vertex format, a restriction which would have crippled our design. D3D9 is the first version to have a genuinely useful VBO design. As for OpenGL, nVidia and ATI has their own, very separate extensions to the GL API to manage VBOs - these have only recently been standardised (Feb 2003) into the ARB_vertex_buffer_object extension. So we saw this as the best possible time to bring this new feature into OGRE.

@section More than just hardware buffers
Besides allowing buffers to be held on the GPU / AGP memory, we also took the opportunity to completely overhaul the way we represent geometry formats in the engine. Previously, the GeometryData and RenderOperation classes held explicit pointers to elements of the vertex, e.g. a pointer to the positions, a pointer to the normals etc. The type and format of the vertex elements was fixed (positions always had to be 3 floats for example), because that's how cards used too work. The latest generation of cards allow a lot more flexibility around what data you feed into them - for example if you like you can omit positions and generate them in the vertex shader, or use a 4D normal vector, among many other things. 
@*@*
In addition, since hardware buffers can be very large, there is more incentive to try to reuse and share buffers between meshes, perhaps using subsets of the same buffer for different purposes, perhaps even changing vertex format half way through the buffer - this sharing can be beneficial to performance because changing the source of the 'streams' of vertex data coming into the card can be comparatively expensive.
@*@*
Finally, we also wanted to make it easier to switch the vertex sources used by a given piece of geometry, without changing the information held about the format of the vertex. Therefore we have the concept of buffer bindings - vertex elements (a position for example) are bound to a 'source index' which is not a pointer to a buffer, it's just an identifier. You then 'bind' this index to a real vertex buffer, and you can rebind it to another buffer if you wish later.
@*

@node Hardware Buffers
@chapter Hardware Buffers
Both vertex buffers and index buffers inherit most of their features from the HardwareBuffer class. The general premise with a hardware buffer is that it is an area of memory with which you can do whatever you like; there is no format (vertex or otherwise) associated with the buffer itself - that is entirely up to interpretation by the methods that use it - in that way, a HardwareBuffer is just like an area of memory you might allocate using 'malloc' - the difference being that this memory is likely to be located in GPU or AGP memory. 
@node The Hardware Buffer Manager
@section The Hardware Buffer Manager
The HardwareBufferManager class is the factory hub of all the objects in the new geometry system. You create and destroy the majority of the objects you use to define geometry through this class. It's a Singleton, so you access it by doing HardwareBufferManager::getSingleton() - however be aware that it is only guaranteed to exist after the RenderSystem has been initialised (after you call Root::initialise); this is because the objects created are invariably API-specific, although you will deal with them through one common interface. 
@*@*
For example:
@example
VertexDeclaration* decl = HardwareBufferManager::getSingleton().createVertexDeclaration();
@end example
@example
HardwareVertexBufferSharedPtr* vbuf = 
	HardwareBufferManager::getSingleton().createVertexBuffer(
		3*sizeof(Real), // size of one whole vertex
		numVertices, // number of vertices
		HardwareBuffer::HBU_STATIC_WRITE_ONLY, // usage
		false); // no shadow buffer
@end example
Don't worry about the details of the above, we'll cover that in the later sections. The important thing to remember is to always create objects through the HardwareBufferManager, don't use 'new' (it won't work anyway in most cases).
@node Buffer Usage
@section Buffer Usage
Because the memory in a hardware buffer is likely to be under significant contention during the rendering of a scene, the kind of access you need to the buffer over the time it is used is extremely important; whether you need to update the contents of the buffer regularly, whether you need to be able to read information back from it, these are all important factors to how the graphics card manages the buffer. The method and exact parameters used to create a buffer depends on whether you are creating an index or vertex buffer (@xref{Hardware Vertex Buffers} and @xref{Hardware Index Buffers}), however one creation parameter is common to them both - the 'usage'. 
@*@*
The most optimal type of hardware buffer is one which is not updated often, and is never read from. The usage parameter of createVertexBuffer or createIndexBuffer can be one of the following:
@table @code
@item HBU_STATIC
This means you do not need to update the buffer very often, but you might occasionally want to read from it.

@item HBU_STATIC_WRITE_ONLY
This means you do not need to update the buffer very often, and you do not need to read from it. However, you may read from it's shadow buffer if you set one up (@xref{Shadow Buffers}). This is the optimal buffer usage setting.

@item HBU_DYNAMIC
This means you expect to update the buffer often, and that you may wish to read from it. This is the least optimal buffer setting.

@item HBU_DYNAMIC_WRITE_ONLY
This means you expect to update the buffer often, but that you never want to read from it. However, you may read from it's shadow buffer if you set one up (@xref{Shadow Buffers}).

@end table
Choosing the usage of your buffers carefully is important to getting optimal performance out of your geometry. If you have a situation where you need to update a vertex buffer often, consider whether you actually need to update @strong{all} the parts of it, or just some. If it's the latter, consider using more than one buffer, with only the data you need to modify in the HBU_DYNAMIC buffer.
@*@*
Always try to use the _WRITE_ONLY forms. This just means that you cannot read @emph{directly} from the hardware buffer, which is good practice because reading from hardware buffers is very slow. If you really need to read data back, use a shadow buffer, described in the next section.

@node Shadow Buffers
@section Shadow Buffers
As discussed in the previous section, reading data back from a hardware buffer performs very badly. However, if you have a cast-iron need to read the contents of the vertex buffer, you should set the 'shadowBuffer' parameter of createVertexBuffer or createIndexBuffer to 'true'. This causes the hardware buffer to be backed with a system memory copy, which you can read from with no more penalty than reading ordinary memory. The catch is that when you write data into this buffer, it will first update the system memory copy, then it will update the hardware buffer, as separate copying process - therefore this technique has an additional overhead when writing data. Don't use it unless you really need it.

@node Locking buffers
@section Locking buffers
In order to read or update a hardware buffer, you have to 'lock' it. This performs 2 functions - it tells the card that you want access to the buffer (which can have an effect on its rendering queue), and it returns a pointer which you can manipulate. Note that if you've asked to read the buffer (and remember, you really shouldn't unless you've set the buffer up with a shadow buffer), the contents of the hardware buffer will have been copied into system memory somewhere in order for you to get access to it. For the same reason, when you're finished with the buffer you must unlock it; if you locked the buffer for writing this will trigger the process of uploading the modified information to the graphics hardware.
@*@*
@subsection Lock parameters
When you lock a buffer, you call one of the following methods:
@example
// Lock the entire buffer
pBuffer->lock(lockType);
// Lock only part of the buffer
pBuffer->lock(start, length, lockType);
@end example
The first call locks the entire buffer, the second locks only the section from 'start' (as a byte offset), for 'length' bytes. This could be faster than locking hte entire buffer since less is transferred, but not if you later update the rest of the buffer too, because doing it in small chunks like this means you cannot use HBL_DISCARD (see below).
@*@*
The lockType parameter can have a large effect on the performance of your application, especially if you are not using a shadow buffer. 
@table @code
@item HBL_NORMAL
This kind of lock allows reading and writing from the buffer - it's also the least optimal because basically you're telling the card you could be doing anything at all. If you're not using a shadow buffer, it requires the buffer to be transferred from the card and back again. If you're using a shadow buffer the effect is minimal.
@item HBL_READ_ONLY
This means you only want to read the contents of the buffer. Best used when you created the buffer with a shadow buffer because in that case the data does not have to be downloaded from the card.
@item HBL_DISCARD
This means you are happy for the card to discard the @emph{entire current contents} of the buffer. Implicitly this means you are not going to read the data - it also means that the card can avoid any stalls if the buffer is currently being rendered from, because it will actually give you an entirely different one. Use this wherever possible when you are locking a buffer which was not created with a shadow buffer. If you are using a shadow buffer it matters less, although with a shadow buffer it's preferable to lock the entire buffer at once, because that allows the shadow buffer to use HBL_DISCARD when it uploads the updated contents to the real buffer.
@item HBL_NO_OVERWRITE
This is useful if you are locking just part of the buffer and thus cannot use HBL_DISCARD. It tells the card that you promise not to modify any section of the buffer which has already been used in a rendering operation this frame. Again this is only useful on buffers with no shadow buffer.
@end table

Once you have locked a buffer, you can use the pointer returned however you wish (just don't bother trying to read the data that's there if you've used HBL_DISCARD, or write the data if you've used HBL_READ_ONLY). Modifying the contents depends on the type of buffer, @xref{Hardware Vertex Buffers} and @xref{Hardware Index Buffers}

@node Practical Buffer Tips
@section Practical Buffer Tips
The interplay of usage mode on creation, and locking options when reading / updating is important for performance. Here's some tips:
@enumerate
@item
Aim for the 'perfect' buffer by creating with HBU_STATIC_WRITE_ONLY, with no shadow buffer, and locking all of it once only with HBL_DISCARD to populate it. Never touch it again.
@item 
If you need to update a buffer regularly, you will have to compromise. Use HBU_DYNAMIC_WRITE_ONLY when creating (still no shadow buffer), and use HBL_DISCARD to lock the entire buffer, or if you can't then use HBL_NO_OVERWRITE to lock parts of it. 
@item
If you really need to read data from the buffer, create it with a shadow buffer. Make sure you use HBL_READ_ONLY when locking for reading because it will avoid the upload normally associated with unlocking the buffer. You can also combine this with either of the 2 previous points, obviously try for static if you can - remember that the _WRITE_ONLY' part refers to the hardware buffer so can be safely used with a shadow buffer you read from. 
@item
Split your vertex buffers up if you find that your usage patterns for different elements of the vertex are different. No point having one huge updateable buffer with all the vertex data in it, if all you need to update is the texture coordinates. Split that part out into it's own buffer and make the rest HBU_STATIC_WRITE_ONLY.
@end enumerate


@node Hardware Vertex Buffers
@chapter Hardware Vertex Buffers
This section covers the first element of the new geometry information, that of defining vertex data. 

@node The VertexData class
@section The VertexData class
The VertexData class collects together all the vertex-related information used to render geometry. The new RenderOperation requires a pointer to a VertexData object, and it is also used in Mesh and SubMesh to store the vertex positions, normals, texture coordinates etc. VertexData can either be used alone (in order to render unindexed geometry, where the stream of vertices defines the triangles), or in combination with IndexData where the triangles are defined by indexes which refer to the entries in VertexData.
@*@*
The VertexData class has a number of important members:
@itemize @bullet
@item
vertexDeclaration - a pointer to a VertexDeclaration object which defines the format of the vertex input; note this is created for you by VertexData. @xref{Vertex Declarations} 
@item
vertexBufferBinding - pointer to a VertexBufferBinding object which defines which vertex buffers are bound to which sources - again, this is created for you by VertexData. @xref{Vertex Buffer Bindings}


@node Vertex Declarations
@section Vertex Declarations
Vertex declarations
@node Vertex Buffer Bindings
@section Vertex Buffer Bindings
Vertex declarations

@node Hardware Index Buffers
@chapter Hardware Index Buffers
Test

@bye
